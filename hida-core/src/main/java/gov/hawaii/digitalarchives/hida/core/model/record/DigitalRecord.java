
package gov.hawaii.digitalarchives.hida.core.model.record;

import gov.hawaii.digitalarchives.hida.core.model.Event;
import gov.hawaii.digitalarchives.hida.core.model.Eventful;
import gov.hawaii.digitalarchives.hida.core.model.accession.Accession;
import gov.hawaii.digitalarchives.hida.core.model.digitalobject.FileObject;
import gov.hawaii.digitalarchives.hida.core.util.Lists;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.PersistenceContext;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.persistence.Version;
import javax.validation.constraints.NotNull;

import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.slf4j.Logger;
import org.springbyexample.util.log.AutowiredLogger;
import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.transaction.annotation.Transactional;


/**
 * The DigitalRecord model class.
 *
 * @author Dongie Agnir
 * @author Keone Hiraide
 */
@Entity
@Configurable
@Table(name = "DIGITAL_RECORD")
public class DigitalRecord implements Serializable, Eventful{

    /**
     * Autogenerated for this entity to be serializable. Implementing
     * Serializable isn't strictly necessary as far as the JPA specification
     * is concerned. However, it is needed if you're going to use caching or
     * EJB remoting, both of which require objects to be Serializable.
     * Caching is a key component in achieving optimal performance in any
     * JPA application, so implementing the Serializable interface is a good
     * habit to adopt. Note: This was taken from the book titled, 
     * "Spring Persistence with Hibernate", 2010, Fisher and Murphy. 
     */
    private static final long serialVersionUID = 2905099069016030549L;

    /** The ARK Unique Identifier for the record. */
    @Id
    @NotNull
    @Column(name = "DIGITAL_RECORD_ID", unique = true)
    private String primaryId;
    
    /**
     * Specifies the version field or property of an entity class that serves 
     * as its optimistic lock value. The version is used to ensure 
     * integrity when performing the merge operation and for optimistic 
     * concurrency control. 
     */
    @Version
    @Column(name = "VERSION")
    private Integer version;
    
    /** The ID of the {@link Accession} that this record is a part of.*/
    @Column(name = "ACCESSION_ID")
    private String accessionId;

    /** The {@code Agent} that is responsible for creating this 
     * {@code DigitalRecord}.
     */
    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name = "CREATOR_ID")
    private Agent creator;

    /**
     * The {@code Agent} that is responsible for preserving this
     * {@code DigitalRecord}.  (Hint: US!)
     */
    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name = "PRESERVER_ID")
    private Agent preserver;

    /** The title of this record.*/
    @Column(name = "TITLE")
    private String title;

    /**
     * The information about the producer responsible for creating this
     * record.
     */
    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name = "PRODUCER_INFO_ID")
    private ProducerInfo producerInfo;

    /** The ID given to the record by the producing agency. */
    @Column(name = "AGENCY_RECORD_ID")
    private String agencyRecordId;

    /**
     * Information about the retention schedule associated with this
     * record.
     */
    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name = "RETENTION_INFO_ID")
    private RetentionInfo retentionInfo;

    /**
     * The date the record (<b>NOTE:</b> record as in the digital
     * record this object represents) was created.
     */
    @Column(name = "CREATED_DATE")
    private Date createdDate;

    /**
     * A list of strings indicating the languages that are contained
     * within this digital record.
     */
    @OneToMany(cascade=CascadeType.ALL, mappedBy="digitalRecord")
    private List<RecordLanguage> languages = Lists.newArrayList();

    /**
     * Any {@link RightsStatement}s associated with this Record or any
     * of the {@link FileObject}s associated with it.  The {@code List} is
     * guaranteed to not be null, and can be safely modified by the caller.
     */
    @OneToMany(cascade=CascadeType.ALL, mappedBy="digitalRecord")
    private List<RightsStatement> rightsStatements = Lists.newArrayList();

    /**
     * The list of {@code MetadataEntry} entries for this Record.
     * {@code List} is guaranteed to be not null, and may be safely modified
     * by the caller.
     */
    @OneToMany(cascade=CascadeType.ALL)
    private Map<String, MetadataEntry> metadataEntries = 
            new LinkedHashMap<String, MetadataEntry>();
    
    /**
     * An {@link EntityManager} instance is associated with a persistence 
     * context. A persistence context is a set of entity instances in which 
     * for any persistent entity identity there is a unique entity instance. 
     * Within the persistence context,the entity instances and their life cycle
     * are  managed. The EntityManager API is used to create and remove 
     * persistent entity instances, to find  entities by their primary key, 
     * and to query over entities. As long as an object is attached to an 
     * EntityManager, all changes to the object will be synchronized with 
     * the database automatically (Meaning that this object is attached to the
     * 'persistence context'). 
     */
    @PersistenceContext
    transient EntityManager entityManager;


    /** Autowired logger to log this class */
    @AutowiredLogger
    private transient Logger log = null;
    
    /**
     * Each stage generates events containing information of what happened to
     * the content of this accession.
     */
    @OneToMany(cascade = CascadeType.ALL)
    private Set<Event> events = new TreeSet<>();
    
    @Transient
    private String pipPath = null;
    
    @Transient
    private int nativeDigitalObjectCount = 0;
    
    @Transient
    private int totalDigitalObjectCount = 0;
    
    @Transient
    private int characterizedDigitalObjectCount = 0;
    
    @Transient 
    private Boolean characterized = null;
    
    /**
     * A new entity manager is created for every persistence related function. 
     * This pattern is called an “entitymanger-per-request” pattern. 
     * In this model, a request from the client is sent to the server 
     * (where the JPA persistence layer runs), a new EntityManager is opened, 
     * and all database operations are executed in this unit of work. Once the 
     * work has been completed (and the response for the client has been
     * prepared), the persistence context is flushed and closed, as well 
     * as the entity manager object. You would also use a single database 
     * transaction to serve the clients request. The relationship between 
     * the two is one-to-one and this model is a perfect fit for many 
     * applications.
     *  
     * http://docs.jboss.org/hibernate/entitymanager/
     *  
     * @return A new EntityManager to do database operations.
     */
    public static final EntityManager entityManager() {
        staticMethodLogger().debug("Entering entityManager()");
        EntityManager em = new DigitalRecord().entityManager;
        if (em == null)  {
            String errorMessage = "Entity manager has not been injected " +
                    "(is the Spring Aspects JAR configured as an AJC/AJDT aspects library?'";
            staticMethodLogger().error(errorMessage);
            throw new IllegalStateException(errorMessage);
        }
        staticMethodLogger().debug("Exiting entityManager(): {}", em);
        return em;
    }
    
    /**
     * Used to log static methods of this class. Since
     * Autowired logger cannot be "static", this method allows an 
     * Autowired Logger to be used within static methods.
     * 
     * @return A new logger to do logging operations.
     */
    private static final Logger staticMethodLogger() {
        Logger log = new DigitalRecord().log;
        if (log == null) {
            throw new IllegalStateException("Logger has not been"
                + " injected!");
        }
        return log;
    }
    
    @Override
    public void addEvent(final Event event) {
        log.debug("Entering addEvent(event={})", event);
        this.events.add(event);
        log.debug("Exiting addEvent()");
    }
    
    @Override
    public Set<Event> getEvents() {
        log.debug("Entering getEvent()");
        log.debug("Exiting getEvent(): {}", events);
        return events;
    }
    
    /**
     * @return The ID of this record.
     */
    public String getPrimaryId() {
        log.debug("Entering getPrimaryId()");
        log.debug("Exiting from getPrimaryId(): {}", primaryId);
        return primaryId;
    }

    /**
     * Set the ID of the record.
     *
     * @param primaryId The ID of this {@code DigitalRecord}.
     */    
    public void setPrimaryId(final String primaryId) {
        log.debug("Entering setPrimaryId(primaryId = {})", primaryId);
        this.primaryId = primaryId;
        log.debug("Exiting setPrimaryId()");
    }

    /**
     * @return The ID of the {@link Accession} that this record is a part of.
     */
    public String getAccessionId() {
        log.debug("Entering getAccessionId()");
        log.debug("Exiting from getAccessionId(): {}", accessionId);
        return accessionId;
    }

    /**
     * Set the ID of the {@link Accession} that this record is a part of.
     *
     * @param accessionId The ID of the {@code Accession}.
     */
    public void setAccessionId(final String accessionId) {
        log.debug("Entering setAccessionId(accessionId = {})", accessionId);
        this.accessionId = accessionId;
        log.debug("Exiting setAccessionId()");
    }

    /**
     * @return The {@code Agent} that is responsible for creating this
     * {@code DigitalRecord}.
     */
    public Agent getCreator() {
        log.debug("Entering getCreator()");
        log.debug("Exiting getCreator(): {}", creator);
        return creator;
    }

    /**
     * Set the {@code Agent} who created this record.
     * @param creator The creating {@code creator}.
     *
     */
    public void setCreator(final Agent creator) {
        log.debug("Entering setCreator(creator = {})", creator);
        this.creator = creator;
        log.debug("Entering getCreator()");
    }

    /**
     * @return The {@code Agent} that is responsible for preserving this
     * {@code DigitalRecord}.  (Hint: US!)
     */
    public Agent getPreserver() {
        log.debug("Entering getPreserver()");
        log.debug("Exiting getPreserver(): {}", preserver);
        return preserver;
    }

    /**
     * Set the {@code Agent} who is preserving this record.
     * 
     * @param preserver The preserving {@code Agent}.
     */
    public void setPreserver(final Agent preserver) {
        log.debug("Entering setPreserver(preserver = {})", preserver);
        this.preserver = preserver;
        log.debug("Exiting setPreserver()");
    }

    /**
     * @return The information about the producer reponsible for creating this
     * record.
     */
    public ProducerInfo getProducerInfo() {
        log.debug("Entering getProducerInfo()");
        log.debug("Exiting from getProducerInfo(): {})", producerInfo);
        return producerInfo;
    }

    /**
     * Set the producer information.
     *
     * @param producerInfo The information about the producer.
     */
    public void setProducerInfo(final ProducerInfo producerInfo) {
        log.debug("Entering setProducerInfo(producerInfo = {})", producerInfo);
        this.producerInfo = producerInfo;
        log.debug("Exiting setProducerInfo()");
    }

    /**
     * @return The title of this record.
     */
    public String getTitle() {
        log.debug("Entering getTitle()");
        log.debug("Exiting getTitle(): {}", title);
        return title;
    }

    
    
    /**
     * Set the title of the record.
     *
     * @param title The title of the record.
     */
    public void setTitle(final String title) {
        log.debug("Entering setTitle(title = {})", title);
        this.title = title;
        log.debug("Exiting setTitle()");
    }

    
    
    /**
     * @return The ID given to the record by the producing agency.
     */
    public String getAgencyRecordId() {
        log.debug("Entering getAgencyRecordId()");
        log.debug("Exiting getAngencyRecordId(): {}", agencyRecordId.toString());
        return agencyRecordId.toString();
    }

    
    
    /**
     * Set the ID given to the record by the producing agency.
     *
     * @param agencyRecordId The ID of the record that has been assigned to it
     * by the producing Agency.
     */
    public void setAgencyRecordId(final String agencyRecordId) {
        log.debug("Entering setAgencyRecordId(agencyRecordId = {})", agencyRecordId);
        this.agencyRecordId = agencyRecordId;
        log.debug("Exiting setAgencyRecordId()");
    }

    
    
    /**
     * @return Information about the retention schedule associated with this
     * record.
     */    
    public RetentionInfo getRetentionInfo() {
        log.debug("Entering getRetentionInfo()");
        log.debug("Exiting getRetentionInfo(): {}", retentionInfo);
        return retentionInfo;
    }

    
    
    /**
     * Set the retention information related to this record.
     *
     * @param retentionInfo The retention information for this record.
     */
    public void setRetentionInfo(final RetentionInfo retentionInfo) {
        log.debug("Entering setRetentionInfo(retentionInfo = {})", retentionInfo);
        this.retentionInfo = retentionInfo;
        log.debug("Exiting setRetentionInfo()");
    }

    
    
    /**
     * @return The date the record (<b>NOTE:</b> record as in the digital
     * record this object represents) was created.
     */
    public Date getCreatedDate() {
        log.debug("Entering getCreatedDate()");
        if (createdDate != null) {
            Date createdDate = new Date(this.createdDate.getTime());
            log.debug("Exiting getCreatedDate(): {}", createdDate);
            return createdDate;
        } else {
            log.debug("Exiting getCreatedDate(): null");
            return null;
        }
    }

    
    
    /**
     * Set the creation date for the digital record.
     *
     * @param date The date the record was created on.
     */
    public void setCreatedDate(final Date date) {
        log.debug("Entering setCreatedDate(createdDate = {})", date);
        if (date != null) {
            this.createdDate = new Date(date.getTime());
        } else {
            this.createdDate = null;
        }
        log.debug("Exiting setCreatedDate()");
    }

    
    
    /**
     * @return A list of strings indicating the languages that are contained
     * within this digital record.
     */
    public List<RecordLanguage> getLanguages() {
        log.debug("Entering getLanguages()");
        List<RecordLanguage> languages = new ArrayList<RecordLanguage>(this.languages);
        log.debug("Exiting getLanguages(): {}", languages);
        return languages;
    }

    
    
    /**
     * Add a language the list of languages that are contained in within this 
     * digital record.
     *
     * @param language The list of languages.
     */
    public void addLanguage(final RecordLanguage language) {
        log.debug("Entering addLangauge(language = {})", language);
        this.languages.add(language);
        log.debug("Exiting addLanguage()");
    }

    
    
    /**
     * @return Any {@link RightsStatement}s associated with this Record or any
     * of the {@link FileObject}s associated with it.  The {@code List} is
     * guaranteed to not be null, and can be safely modified by the caller.
     */
    public List<RightsStatement> getRightsStatements() {
        log.debug("Entering getRightsStatements()");
        List<RightsStatement> rightsStatements = 
                new ArrayList<RightsStatement>(this.rightsStatements);
        log.debug("Exiting getRightsStatements(): {}", rightsStatements);
        return rightsStatements;
    }

    
    
    /**
     * Add a {@link RightsStatement}s associated with this Record or any
     * of the {@link FileObject}s associated with it.
     *
     * @param rightsStatement The {@code RightsStatement} to add.
     */
    public void addRightsStatement(RightsStatement rightsStatement) {
        log.debug("Entering setRightsStatements(rightsStatements = {})", rightsStatement);
        this.rightsStatements.add(rightsStatement);
        log.debug("Exiting addRightsStatement()");
    }

    
    
    /**
     * @return The list of {@code MetadataEntry} entries for this Record.
     * {@code List} is guaranteed to be not null, and may be safely modified
     * by the caller.
     */
    public List<MetadataEntry> getMetadataEntries() {
        log.debug("Entering getMetadataEntries()");
        List<MetadataEntry> metadataEntries = 
                new ArrayList<MetadataEntry>(this.metadataEntries.values());
        log.debug("Exiting getMetadataEntries(): {}", metadataEntries);
        return metadataEntries;
    }

    
    
    /**
     * Add a {@code MetadataEntry} to this Record.
     *
     * @param entry The entry to add to this {@code Record}.  Must not be
     * null.
     */
    public void addMetadataEntry(MetadataEntry entry) {
        log.debug("Entering addMetadataEntry(entry = {})", entry);
        if (entry == null) {
            log.error("'entry' cannot be null in addMetadataEntry(entry) = {}", entry);
            throw new IllegalArgumentException("entry cannot be null");
        }
        metadataEntries.put(entry.getName(), entry);
        log.debug("Exiting addMetadataEntry()");
    }
    
    /** @param pipPath The Path to the PIP associated with this record, or null
     *            (the default value) to indicate that record has not been
     *            processed. Should be relative to the processing directory. */
    public void setPipPath (String pipPath)
    {
        this.pipPath = pipPath;
    }

    /** @return The Path to the PIP directory associated with this record, or null
     *         if record has not been processed. Should be relative to the
     *         processing directory. */
    public String getPipPath ()
    {
        return this.pipPath;
    }
    
    /** @param nativeDigitalObjectCount The number of native digital objects
     *            associated with this record. */
    public void setNativeDigitalObjectCount (int nativeDigitalObjectCount)
    {
        this.nativeDigitalObjectCount = nativeDigitalObjectCount;
    }

    /** @return The number of native digital objects associated with this record. */
    public int getNativeDigitalObjectCount ()
    {
        return this.nativeDigitalObjectCount;
    }

    /** @param totalDigitalObjectCount The total number of digital objects
     *            associated with this record. */
    public void setTotalDigitalObjectCount (int totalDigitalObjectCount)
    {
        this.totalDigitalObjectCount = totalDigitalObjectCount;
    }

    /** @return The total number of digital objects associated with this record. */
    public int getTotalDigitalObjectCount ()
    {
        return this.totalDigitalObjectCount;
    }


    /** @param characterizedDigitalObjectCount The total number of 
     *          characterized digital objects associated with this record. */
    public void setCharacterizedDigitalObjectCount (int characterizedDigitalObjectCount)
    {
        this.characterizedDigitalObjectCount = characterizedDigitalObjectCount;
    }

    /** @return The total number of characterized digital objects associated 
     *          with this record. */
    public int getCharacterizedDigitalObjectCount ()
    {
        return this.characterizedDigitalObjectCount;
    }
    
    /**
     *  Assists in implementing Object.toString() methods using reflection.
     *  This class uses reflection to determine the fields to append. Because 
     *  these fields are usually private, the class changes the visibility of 
     *  the fields. This will fail under a security manager,
     *  unless the appropriate permissions are set up correctly. 
     */
    @Override
    public String toString() {
        log.debug("Entering toString()");
        String toString = ReflectionToStringBuilder.toString(this,
                ToStringStyle.SHORT_PREFIX_STYLE);
        log.debug("Exiting toString(): {}", toString);
        return toString;
    }
        
    
    
    /**
     * Gets the amount of DigitalRecord objects that are currently 
     * in the database.
     * 
     * @return The amount of DigitalRecord objects that are 
     *         currently in the database.
     */
    public static long countDigitalRecords() {
        staticMethodLogger().debug("Entering countDigitalRecords()");
        long count = entityManager()
                .createQuery("SELECT COUNT(o) FROM DigitalRecord o", Long.class)
                .getSingleResult();
        staticMethodLogger().debug("Exiting countDigitalRecords(): {}", count);
        return count;
    }

    
    
    /**
     * Gets all of the DigitalRecord objects from the database 
     * and puts them in a collection. 
     * 
     * @return The collection of DigitalRecords that are 
     *         in the database.
     */
    public static List<DigitalRecord> findAllDigitalRecords() {
        staticMethodLogger().debug("Entering findAllDigitalRecords()");
        List<DigitalRecord> digitalRecords = entityManager()
                .createQuery("SELECT o FROM DigitalRecord o", DigitalRecord.class)
                .getResultList();
        staticMethodLogger().debug("Exiting findAllDigitalRecords(): {}", digitalRecords);
        return digitalRecords;
    }

    
    
    /**
     * Queries for a DigitalRecord based on its primaryId.
     * 
     * @param primaryId  The String primaryId associated with the 
     *                   DigitalRecord that you want to search the database 
     *                   for.
     * @return  The associated DigitalRecord matching the primaryId you were
     *          searching for, or null if not found.
     */
    public static DigitalRecord findDigitalRecord(String primaryId) {
        staticMethodLogger().debug("Entering findDigitalRecord(primaryId = {})", primaryId);
        if (primaryId == null || primaryId.length() <= 0) {
            staticMethodLogger().debug("Exiting findDigitalRecord(): null)");
            return null;
        }
        DigitalRecord digitalRecord = entityManager().find(DigitalRecord.class, primaryId);
        staticMethodLogger().debug("Exiting findDigitalRecord(): {})", digitalRecord);
        return digitalRecord;
    }

    
    
    /**
     * Gets a certain subset of DigitalRecords based 
     * on the range desired.
     * 
     * @param firstResult  The beginning of the range of values.
     * @param maxResults   The last element of the range of values.
     * @return             The collection of DigitalRecords based 
     *                     on the range desired. 
     */
    public static List<DigitalRecord> findDigitalRecordEntries(int firstResult, int maxResults) {
        staticMethodLogger()
        .debug("Entering findDigitalRecordEntries(firstResult = {}, maxResults = {})",
                firstResult, maxResults);
        
        List<DigitalRecord> digitalRecords = entityManager()
                .createQuery("SELECT o FROM DigitalRecord o", DigitalRecord.class)
                .setFirstResult(firstResult).setMaxResults(maxResults).getResultList();
        
        staticMethodLogger().debug("Exiting findDigitalRecordEntries(): {}", digitalRecords);
        return digitalRecords;
    }

    
    
    /**
     * Persists this object to the persistence context. 
     */
    @Transactional
    public void persist() {
        log.debug("Entering persist()");
        if (this.entityManager == null)
            this.entityManager = entityManager();
        this.entityManager.persist(this);
        log.debug("Exiting persist()");
    }

    
    
    /**
     * Removes this object from the persistence context. 
     */
    @Transactional
    public void remove() {
        log.debug("Entering remove()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        if (this.entityManager.contains(this)) {
            this.entityManager.remove(this);
        } else {
            DigitalRecord attached = DigitalRecord.findDigitalRecord(this.primaryId);
            this.entityManager.remove(attached);
        }
        log.debug("Exiting remove()");
    }

    
    
    /**
     * Synchronize the persistence context to the underlying database. 
     */
    @Transactional
    public void flush() {
        log.debug("Entering flush()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        this.entityManager.flush();
        log.debug("Exiting flush()");
    }

    
    
    /**
     * If you call clear, all currently managed objects of the EntityManager 
     * will be detached and the status is not synchronized with the database. 
     * As long as the objects are not explicitly attached again, they are 
     * standard Java objects, whose change does not have any effect on 
     * the database.
     */
    @Transactional
    public void clear() {
        log.debug("Entering clear()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        this.entityManager.clear();
        log.debug("Exiting clear()");
    }

    
    
    /**
     * If this object is detached, the merge() method will merge them back into
     * the EntityManager to become managed again. Note that changes to detached
     * entity objects are not stored in the database.
     * 
     * @return The merged DigitalRecord.
     */
    @Transactional
    public DigitalRecord merge() {
        log.debug("Entering merge()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        DigitalRecord merged = this.entityManager.merge(this);
        this.entityManager.flush();
        log.debug("Exiting merge(): {}", merged);
        return merged;
    }

    
    /**
     * Gets the version of this DigitalRecord.
     * 
     * @return  The version of this DigitalRecord.
     */
    public Integer getVersion() {
        log.debug("Entering getVersion()");
        log.debug("Exiting getVersion(): {}", this.version);
        return this.version;
    }

    
    
    /**
     * Sets the version of this DigitalRecord.
     * 
     * @param version  The version of this DigitalRecord.
     */
    public void setVersion(Integer version) {
        log.debug("Entering setVersion(version = {})", version);
        this.version = version;
        log.debug("Exiting setVersion()");
    }


    
    /**
     * @return {@link RightsStatement}s associated with this Record or any
     * of the {@link FileObject}s associated with it.
     */
    public void setRightsStatements(List<RightsStatement> rightsStatements) {
        log.debug("Entering setRightsStatements(rightsStatements = {})", rightsStatements);
        this.rightsStatements = new ArrayList<RightsStatement>(rightsStatements);
        log.debug("Exiting setRightsStatements()");
    }

    
    
    /**
     * The list of {@code MetadataEntry} entries for this Record.
     * {@code List} is guaranteed to be not null, and may be safely modified
     * by the caller.
     */
    public void setMetadataEntries(Map<String, MetadataEntry> metadataEntries) {
        log.debug("Entering setMetadataEntries(metadataEntries = {})", metadataEntries);
        this.metadataEntries = new LinkedHashMap<String, MetadataEntry>(metadataEntries);
        log.debug("Exiting setMetadataEntries()");
    }
    
    /**
     * Sets the logger for this class.
     * 
     * @param log The logger for this class.
     */
    @AutowiredLogger
    public void setLog(Logger log) {
        this.log = log;
    }
    
    /**
     * @return True if the digital object has been characterized, false if it
     *         failed to be characterized, or null if it has not been
     *         characterized.
     */
    public Boolean isCharacterized () {
        return this.characterized;
    }

    /**
     * @param characterized Set true if characterized or false if it has not
     *            been characterized.
     */
    public void setCharacterized (boolean characterized) {
        this.characterized = characterized;
    }
}
