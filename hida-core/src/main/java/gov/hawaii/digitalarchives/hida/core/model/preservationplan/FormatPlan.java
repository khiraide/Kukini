package gov.hawaii.digitalarchives.hida.core.model.preservationplan;
import java.io.Serializable;
import java.util.List;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import javax.persistence.PersistenceContext;
import javax.persistence.Version;
import javax.validation.constraints.NotNull;

import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.hibernate.validator.constraints.NotEmpty;
import org.slf4j.Logger;
import org.springbyexample.util.log.AutowiredLogger;
import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.util.Assert;

/**
 * Model class which represents the format plans associated with a 
 * {@link PreservationPlan}. Contains the PRONOM format ID and the various 
 * native file formats associated with this FormatPlan.
 * 
 * @author Keone Hiraide
 */
@Entity
@Configurable
public class FormatPlan implements Serializable {
    
    /**
     * Autogenerated for this entity to be serializable. Implementing
     * Serializable isn't strictly necessary as far as the JPA specification
     * is concerned. However, it is needed if you're going to use caching or
     * EJB remoting, both of which require objects to be Serializable.
     * Caching is a key component in achieving optimal performance in any
     * JPA application, so implementing the Serializable interface is a good
     * habit to adopt. Note: This was taken from the book titled, 
     * "Spring Persistence with Hibernate", 2010, Fisher and Murphy. 
     */
    private static final long serialVersionUID = -1922505191418354771L;

    /**
     * PRONOM ID of this FormatPlan.
     */
    @Id
    @NotEmpty
    @Column(name = "FORMAT_PLAN_ID", unique = true, nullable = false)
    private String primaryId;
    
    /**
     * Specifies the version field or property of an entity class that serves 
     * as its optimistic lock value. The version is used to ensure 
     * integrity when performing the merge operation and for optimistic 
     * concurrency control. 
     */
    @NotNull
    @Version
    @Column(name = "VERSION", nullable = false)
    private Integer version;
    
    /**
     * The native {@link FileFormat} associated with this format plan.
     */
    @NotNull
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name="NATIVE_FORMAT",insertable=true,
    updatable=true,nullable=false,unique=false)
    private FileFormat nativeFormat;
    
    /**
     * The preservation {@link FileFormat} associated with this format plan.
     */
    @NotNull
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name="PRESERVATION_FORMAT",insertable=true,
    updatable=true,nullable=false,unique=false)
    private FileFormat preservationFormat;

    /**
     * The presentation {@link FileFormat} associated with this format plan.
     */
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name="PRESENTATION_FORMAT",insertable=true,
    updatable=true)
    private FileFormat presentationFormat;
    
    /**
     * The thumbnail {@link FileFormat} associated with this format plan.
     */
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name="THUMBNAIL_FORMAT",insertable=true,
    updatable=true)
    private FileFormat thumbnailFormat;

    /**
     * An {@link EntityManager} instance is associated with a persistence 
     * context. A persistence context is a set of entity instances in which 
     * for any persistent entity identity there is a unique entity instance. 
     * Within the persistence context, the entity instances and their life 
     * cycle are  managed. The EntityManager API is used to create and remove 
     * persistent entity instances, to find  entities by their primary key, 
     * and to query over entities. As long as an object is attached to an 
     * EntityManager, all changes to the object will be synchronized with 
     * the database automatically (Meaning that this object is attached to the
     * 'persistence context'). 
     */
    @PersistenceContext
    transient EntityManager entityManager;
    
    /**
     * AutowiredLogger for logging purposes.
     */
    private transient static Logger log = null;
    
    /**
     * Used to log static methods of this class. Since
     * Autowired logger cannot be "static", this method allows an 
     * Autowired Logger to be used within static methods.
     * 
     * @param A logger to do logging operations.
     */
    @AutowiredLogger
    public void setLog(Logger log) {
        FormatPlan.log = log;
    }
    
    /**
     * @return The native {@link FileFormat} associated with this format plan.
     */
    public FileFormat getNativeFormat() {
        log.debug("Entering getNativeFormat()");
        log.debug("Exiting getNativeFormat(): {}", nativeFormat);
        return nativeFormat;
    }

    /**
     * Sets the native {@link FileFormat} associated with this format plan.
     * 
     * @param nativeFormat The native {@link FileFormat} associated with this 
     *                     format plan.
     */
    public void setNativeFormat(FileFormat nativeFormat) {
        log.debug("Entering setNativeFormat(nativeFormat = {})", nativeFormat);
        Assert.notNull(nativeFormat, "nativeFormat cannot be null");
        this.nativeFormat = nativeFormat;
        log.debug("Entering setNativeFormat()");
    }

    
    
    /**
     * @return The preservation {@link FileFormat} associated with this format 
     *         plan.
     */
    public FileFormat getPreservationFormat() {
        log.debug("Entering getPreservationFormat()");
        log.debug("Exiting getPreservationFormat(): {}", preservationFormat);
        return preservationFormat;
    }

    
    
    /**
     * Sets the preservation {@link FileFormat} associated with this format plan.
     * 
     * @param preservationFormat The preservation {@link FileFormat} associated 
     *                           with this format plan.
     */
    public void setPreservationFormat(FileFormat preservationFormat) {
        log.debug("Entering setPreservationFormat(preservationFormat = {})", preservationFormat);
        Assert.notNull(preservationFormat, "preservationFormat cannot be null");
        this.preservationFormat = preservationFormat;
        log.debug("Exiting setPreservationFormat()");
    }

    
    
    /**
     * @return The presentation {@link FileFormat} associated with this format 
     *         plan.
     */
    public FileFormat getPresentationFormat() {
        log.debug("Entering getPresentationFormat()");
        log.debug("Exiting getPresentationFormat(): {}", presentationFormat);
        return presentationFormat;
    }

    
    
    /**
     * Sets the presentation {@link FileFormat} associated with this format plan.
     * 
     * @param presentationFormat The presentation {@link FileFormat} associated 
     *                           with this format plan.
     */
    public void setPresentationFormat(FileFormat presentationFormat) {
        log.debug("Entering setPresentationFormat(presentationFormat = {})", presentationFormat);
        Assert.notNull(presentationFormat, "presentationFormat cannot be null");
        this.presentationFormat = presentationFormat;
        log.debug("Entering setPresentationFormat()");
    }

    
    
    /**
     * @return The thumbnail {@link FileFormat} associated with this format 
     *         plan.
     */
    public FileFormat getThumbnailFormat() {
        log.debug("Entering getThumbnailFormat()");
        log.debug("Exiting getThumbnailFormat(): {}", thumbnailFormat);
        return thumbnailFormat;
    }

    
    
    /**
     * Sets the thumbnail {@link FileFormat} associated with this format plan.
     * 
     * @param thumbnailFormat The thumbnail {@link FileFormat} associated 
     *                           with this format plan.
     */
    public void setThumbnailFormat(FileFormat thumbnailFormat) {
        log.debug("Entering setThumbnailFormat(thumbnailFormat = {})", thumbnailFormat);
        Assert.notNull(thumbnailFormat, "thumbnailFormat cannot be null");
        this.thumbnailFormat = thumbnailFormat;
        log.debug("Entering setThumbnailFormat()");
    }
    
    
    
    /**
     * @return The primary id associated with this format plan.
     */
    public String getPrimaryId() {
        log.debug("Entering getPrimaryId()");
        log.debug("Exiting getPrimaryId(): {}", this.primaryId);
        return this.primaryId;
    }

    
    
    /**
     * Sets the primary id associated with this format plan.
     * @param primaryId The primary id associated with this format plan.
     */
    public void setPrimaryId(String primaryId) {
        log.debug("Entering setPrimaryId(primaryId = {})", primaryId);
        Assert.notNull(primaryId, "primaryId cannot be null");
        Assert.hasLength(primaryId, "primaryId cannot be empty");
        this.primaryId = primaryId;
        log.debug("Exiting setPrimaryId(primaryId)");
    }

   
    
    /**
     * Gets the version of this FormatPlan.
     * 
     * @return The version of this FormatPlan.
     */
    public Integer getVersion() {
        log.debug("Entering getVersion()");
        log.debug("Exiting getVersion(): {}", version);
        return this.version;
    }


    
    /**
     * Sets the version of this FormatPlan.
     * 
     * @param version The version of this FormatPlan.
     */
    public void setVersion(Integer version) {
        log.debug("Entering setVersion(version = {})", version);
        Assert.notNull(version, "version cannot be null");
        this.version = version;
        log.debug("Exiting setVersion()");
    }

    
    
    /**
     * A new entity manager is created for every persistence related function. 
     * This pattern is called an “entitymanger-per-request” pattern. 
     * In this model, a request from the client is sent to the server 
     * (where the JPA persistence layer runs), a new EntityManager is opened, 
     * and all database operations are executed in this unit of work. Once the 
     * work has been completed (and the response for the client has been
     * prepared), the persistence context is flushed and closed, as well 
     * as the entity manager object. You would also use a single database 
     * transaction to serve the clients request. The relationship between 
     * the two is one-to-one and this model is a perfect fit for many 
     * applications.
     *  
     * http://docs.jboss.org/hibernate/entitymanager/
     *  
     * @return A new EntityManager to do database operations.
     */
    public static final EntityManager entityManager() {
        log.debug("Entering entityManager()");
        EntityManager em = new FormatPlan().entityManager;
        if (em == null) {
            String errorMessage = "Entity manager has not been injected "
                + "(is the Spring Aspects JAR configured as an AJC/AJDT aspects library?'";
            
            log.error(errorMessage);
            throw new IllegalStateException(errorMessage);
        }
        log.debug("Exiting entityManager(): {}", em);
        return em;
    }

    
    
    /**
     * Gets the amount of FormatPlan objects that are currently 
     * in the database.
     * 
     * @return The amount of FormatPlan objects that are 
     *         currently in the database.
     */
    public static long countFormatPlans() {
        log.debug("Entering countFormatPlans()");
        long count = entityManager().createQuery("SELECT COUNT(o) FROM FormatPlan o",
                Long.class).getSingleResult();
        log.debug("Exiting countFormatPlans(): {}", count);
        return count;
    }

    
    
    /**
     * Gets all the FormatPlan objects from the database 
     * and puts them in a collection. 
     * 
     * @return The collection of FormatPlans that are 
     *         in the database.
     */
    public static List<FormatPlan> findAllFormatPlans() {
        log.debug("Entering findAllFormatPlans()");
        List<FormatPlan> formatPlans = entityManager().createQuery("SELECT o FROM FormatPlan o",
                FormatPlan.class).getResultList();
        log.debug("Exiting findAllFormatPlans(): {}", formatPlans);
        return formatPlans;
    }

    
    
    /**
     * Queries for a FormatPlan based on its primaryId.
     * 
     * @param primaryId  The String primaryId associated with this FormatPlan.
     * @return The FormatPlan associated with the primaryId that was passed in 
     *         or null if not found.
     */
    public static FormatPlan findFormatPlan(String primaryId) {
        log.debug("Entering findFormatPlan(primaryId = {})", primaryId);
        if (primaryId == null || primaryId.length() <= 0) {
            log.debug("Exiting findFormatPlan(): null)");
            return null;
        }
        FormatPlan formatPlan = entityManager().find(FormatPlan.class, primaryId);
        log.debug("Exiting findFormatPlan(): {})", formatPlan);
        return formatPlan;
    }

    
    
    /**
     * Gets a certain subset of FormatPlans based 
     * on the range desired.
     * 
     * @param firstResult  The beginning of the range of values.
     * @param maxResults   The last element of the range of values.
     * @return             The collection of FormatPlans based 
     *                     on the range desired. 
     */
    public static List<FormatPlan> findFormatPlanEntries(int firstResult, int maxResults) {
        log.debug("Entering findFormatPlanEntries(firstResult = {}, " +
                "maxResults = {})", firstResult, maxResults);
        
        List<FormatPlan> formatPlans = entityManager()
                .createQuery("SELECT o FROM FormatPlan o", FormatPlan.class)
                .setFirstResult(firstResult).setMaxResults(maxResults)
                .getResultList();
        
        log.debug("Exiting findFormatPlanEntries(): {}", formatPlans);
        return formatPlans;
    }

   
     
    /**
     *  Assists in implementing Object.toString() methods using reflection.
     *  This class uses reflection to determine the fields to append. Because 
     *  these fields are usually private, the class changes the visibility of 
     *  the fields. This will fail under a security manager,
     *  unless the appropriate permissions are set up correctly. 
     */
    public String toString() {
        log.debug("Entering toString()");
        String toString = ReflectionToStringBuilder.toString(this,
                ToStringStyle.SHORT_PREFIX_STYLE);
        log.debug("Exiting toString(): {}", toString);
        return toString;
    }
}