package gov.hawaii.digitalarchives.hida.core.model.record;

import gov.hawaii.digitalarchives.hida.core.exception.HidaIdSyntaxException;
import gov.hawaii.digitalarchives.hida.core.model.digitalobject.DigitalObject;

import java.io.Serializable;
import java.util.List;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToOne;
import javax.persistence.PersistenceContext;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.validation.constraints.NotNull;

import org.apache.commons.httpclient.URI;
import org.apache.commons.httpclient.URIException;
import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.slf4j.Logger;
import org.springbyexample.util.log.AutowiredLogger;
import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.transaction.annotation.Transactional;


/**
 * Describes any restrictions put upon any portion of a record or its digital
 * objects.
 * <p>
 * Relation to METS Schema:
 * <p>
 * This class roughly corresponds to the the {@code <METS:rightsMD>} section
 * of the schema, more specifically {@code <PREMIS:rightsStatement>} contained
 * with that.
 * <p>
 * Note that most of the actual information is actually in {@link RightsBasis}.  
 * Depending on the type, they correspond to different sections within the 
 * {@code <PREMIS:rightsStatement>} section.  Consult the documentation of 
 * each.
 *
 * @author Dongie Agnir
 */
@Configurable
@Entity
@Table(name = "RIGHTS_STATEMENT")
public class RightsStatement implements Serializable {
    
    /**
     * Autogenerated for this entity to be serializable. Implementing
     * Serializable isn't strictly necessary as far as the JPA specification
     * is concerned. However, it is needed if you're going to use caching or
     * EJB remoting, both of which require objects to be Serializable.
     * Caching is a key component in achieving optimal performance in any
     * JPA application, so implementing the Serializable interface is a good
     * habit to adopt. Note: This was taken from the book titled, 
     * "Spring Persistence with Hibernate", 2010, Fisher and Murphy. 
     */
    private static final long serialVersionUID = -8715361699396185085L;

    /** The Unique Primary Identifier for a RightsStatement. */
    @Id
    @NotNull
    @Column(name = "RIGHTS_STATEMENT_ID", unique = true)
    private String primaryId;
    
    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name = "RIGHTS_BASIS_ID")
    private RightsBasis basis;
    
    /**
     * Specifies the version field or property of an entity class that serves 
     * as its optimistic lock value. The version is used to ensure 
     * integrity when performing the merge operation and for optimistic 
     * concurrency control. 
     */
    @Version
    @Column(name = "VERSION")
    private Integer version;
    
    /**
     * Many RightsStatement objects are associated with a single DigitalRecord 
     * object. A DigitalRecord object's primary key will be used as a foreign 
     * key in this RightsStatement object/table.
     */
    @ManyToOne(cascade=CascadeType.ALL)
    @JoinColumn(name = "DIGITAL_RECORD")
    private DigitalRecord digitalRecord;
    
    /**
     * @return The set of {@link DigitalObject}s related to this
     * {@code RightsStatement}.
     */
    //TODO When HIDA-139 gets merged with this, 
    // change type from URI to digitalObjects.
    private transient Set<URI> relatedObjects;
    
    
    
    /**
     * An {@link EntityManager} instance is associated with a persistence 
     * context. A persistence context is a set of entity instances in which 
     * for any persistent entity identity there is a unique entity instance. 
     * Within the persistence context,the entity instances and their life cycle
     * are  managed. The EntityManager API is used to create and remove 
     * persistent entity instances, to find  entities by their primary key, 
     * and to query over entities. As long as an object is attached to an 
     * EntityManager, all changes to the object will be synchronized with 
     * the database automatically (Meaning that this object is attached to the
     * 'persistence context'). 
     */
    @PersistenceContext
    transient EntityManager entityManager;
    
    /** Autowired logger to log this class */
    private transient Logger log = null;
    
    /**
     * Oracle specifications state that the class must have a public 
     * or protected, no-argument constructor. The class may have other 
     * constructors. 
     * http://docs.oracle.com/javaee/7/tutorial/doc/persistence-intro001.htm
     */
    public RightsStatement() {
        
    }
    
    
    /**
     * Used to create a RightsStatement object.
     * 
     * @param primaryId     The primaryId associated with this RightsStatement.
     * @param basis         The {@link RightsStatement associated with this
     *                      RightsStatement.
     * @param digitalRecord The {@link DigitalRecord} associated with this
     *                      RightsStatement.
     */
    public RightsStatement(final String primaryId, final RightsBasis basis, 
            final DigitalRecord digitalRecord) {
        this.primaryId = primaryId;
        this.basis = basis;
        this.digitalRecord = digitalRecord;
    }
    
    
    
    /**
     * @return The ID of this {@code RightsStatement}.
     */
    public URI getPrimaryId() {
        log.debug("Entering getPrimaryId()");
        if (this.primaryId == null || this.primaryId.length() <= 0) {
            log.debug("Exiting getPrimaryId(): null");
            return null;
        }
        URI rightsStatementId = null;
        try {
            rightsStatementId = new URI(this.primaryId, false);
        } catch (URIException e) {
            String errorMessage = "Badly formatted URI "
                    + "when rightsStatementId was constructed for the getPrimaryId() "
                    + "method in the RightsStatement class.";
            log.error(errorMessage, e);
            throw new HidaIdSyntaxException(errorMessage, e);
        }
        log.debug("Exiting getPrimaryId(): {}", rightsStatementId);
        return rightsStatementId;
    }

    
    
    /**
     * @return The basis for this Rights Statement.
     */
    public RightsBasis getBasis() {
        log.debug("Entering getBasis()");
        log.debug("Exiting getBasis(): {}", this.basis);
        return this.basis;
    }

    /**
     * @return The set of {@link DigitalObject}s related to this
     * {@code RightsStatement}.
     */
    //TODO When HIDA-139 gets merged with this, 
        // change type from URI to DigitalObjectId?.
    public Set<URI> getRelatedObjects() {
        log.debug("Entering getRelatedObjects()");
        log.debug("Exiting getRelatedObjects(): {}", this.relatedObjects);
        return this.relatedObjects;
    }

    /**
     * A new entity manager is created for every persistence related function. 
     * This pattern is called an “entitymanger-per-request” pattern. 
     * In this model, a request from the client is sent to the server 
     * (where the JPA persistence layer runs), a new EntityManager is opened, 
     * and all database operations are executed in this unit of work. Once the 
     * work has been completed (and the response for the client has been
     * prepared), the persistence context is flushed and closed, as well 
     * as the entity manager object. You would also use a single database 
     * transaction to serve the clients request. The relationship between 
     * the two is one-to-one and this model is a perfect fit for many 
     * applications.
     * 
     * http://docs.jboss.org/hibernate/entitymanager/ 
     * 
     * @return A new EntityManager to do database operations.
     */
    public static final EntityManager entityManager() {
        staticMethodLogger().debug("Entering entityManager()");
        EntityManager em = new RightsStatement().entityManager;
        if (em == null)  {
            String errorMessage = "Entity manager has not been injected "
                    + "(is the Spring Aspects JAR configured as an AJC/AJDT aspects library?'";
            staticMethodLogger().error(errorMessage);
            throw new IllegalStateException(errorMessage);
        }
        
        staticMethodLogger().debug("Exiting entityManager(): {}", em);
        return em;
    }
    
    /**
     * Used to log static methods of this class. Since
     * Autowired logger cannot be "static", this method allows an 
     * Autowired Logger to be used within static methods.
     * 
     * @return A new logger to do logging operations.
     */
    private static final Logger staticMethodLogger() {
        Logger log = new RightsStatement().log;
        if (log == null) {
            throw new IllegalStateException("Logger has not been"
                + " injected!");
        }
        return log;
    }

    /**
     * Gets the amount of RightsStatement objects that are currently 
     * in the database.
     * 
     * @return The amount of RightsStatement objects that are 
     *         currently in the database.
     */
    public static long countRightsStatements() {
        staticMethodLogger().debug("Entering countRightsStatements()");
        long count = entityManager().createQuery("SELECT COUNT(o) FROM RightsStatement o",
                Long.class).getSingleResult();
        staticMethodLogger().debug("Exiting countRightsStatements(): {}", count);
        return count;
    }

    /**
     * Gets all of the RightsStatement objects from the database 
     * and puts them in a collection. 
     * 
     * @return The collection of RightsStatement that are 
     *         in the database.
     */
    public static List<RightsStatement> findAllRightsStatements() {
        staticMethodLogger().debug("Entering findAllRightsStatements()");
        List<RightsStatement> rightsStatements = entityManager()
                .createQuery("SELECT o FROM RightsStatement o", RightsStatement.class)
                .getResultList();
        staticMethodLogger().debug("Exiting findAllRightsStatements(): {}", rightsStatements);
        return rightsStatements;
    }

    /**
     * Queries for a RightsStatement based on its primaryId.
     * 
     * @param primaryId  The String primaryId associated with the 
     *                   RightsStatement that you want to search the database 
     *                   for.
     * @return  The associated RightsStatement matching the primaryId you were
     *          searching for, or null if not found.
     */
    public static RightsStatement findRightsStatement(String primaryId) {
        staticMethodLogger().debug("Entering findRightsStatement(primaryId = {})", primaryId);
        if (primaryId == null) {
            staticMethodLogger().debug("Exiting findRightsStatement(): null)");
            return null;
        }
        RightsStatement rightsStatement = entityManager().find(RightsStatement.class, primaryId);
        staticMethodLogger().debug("Exiting findRightsStatement(): {})", rightsStatement);
        return rightsStatement;
    }

    
    
    /**
     * Gets a certain subset of RightsStatement based 
     * on the range desired.
     * 
     * @param firstResult  The beginning of the range of values.
     * @param maxResults   The last element of the range of values.
     * @return             The collection of RightsStatements based 
     *                     on the range desired. 
     */
    public static List<RightsStatement> findRightsStatementEntries(int firstResult, 
            int maxResults) {
        staticMethodLogger().debug("Entering findRightsStatementEntries(firstResult = {}, " +
                "maxResults = {})",
                firstResult, maxResults);
        
        List<RightsStatement> rightsStatement = entityManager()
                .createQuery("SELECT o FROM RightsStatement o", RightsStatement.class)
                .setFirstResult(firstResult).setMaxResults(maxResults)
                .getResultList();
        
        staticMethodLogger().debug("Exiting findRightsStatementEntries(): {}", rightsStatement);
        return rightsStatement;
    }

    
    
    /**
     * Persists this object to the persistence context. 
     */
    @Transactional
    public void persist() {
        log.debug("Entering persist()");
        if (this.entityManager == null)
            this.entityManager = entityManager();
        this.entityManager.persist(this);
        log.debug("Exiting persist()");
    }

    
    
    /**
     * Removes this object from the persistence context. 
     */
    @Transactional
    public void remove() {
        log.debug("Entering remove()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        if (this.entityManager.contains(this)) {
            this.entityManager.remove(this);
        } else {
            RightsStatement attached = RightsStatement.findRightsStatement(this.primaryId);
            this.entityManager.remove(attached);
        }
        log.debug("Exiting remove()");
    }

    
    
    /**
     * Synchronize the persistence context to the underlying database. 
     */
    @Transactional
    public void flush() {
        log.debug("Entering flush()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        this.entityManager.flush();
        log.debug("Exiting flush()");
    }

    
    
    /**
     * If you call clear, all currently managed objects of the EntityManager 
     * will be detached and the status is not synchronized with the database. 
     * As long as the objects are not explicitly attached again, they are 
     * standard Java objects, whose change does not have any effect on 
     * the database.
     */
    @Transactional
    public void clear() {
        log.debug("Entering clear()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        this.entityManager.clear();
        log.debug("Exiting clear()");
    }

    
    
    /**
     * If this object is detached, the merge() method will merge them back into
     * the EntityManager to become managed again. Note that changes to detached
     * entity objects are not stored in the database.
     * 
     * @return The merged RightsStatement.
     */
    @Transactional
    public RightsStatement merge() {
        log.debug("Entering merge()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        RightsStatement merged = this.entityManager.merge(this);
        this.entityManager.flush();
        log.debug("Exiting merge(): {}", merged);
        return merged;
    }

    
    
    /**
     * Gets the version of this RightsStatement.
     * 
     * @return  The version of this RightsStatement.
     */
    public Integer getVersion() {
        log.debug("Entering getVersion()");
        log.debug("Exiting getVersion(): {}", this.version);
        return this.version;
    }

    
    
    /**
     * Sets the version of this RightsStatement.
     * 
     * @param version  The version of this RightsStatement.
     */
    public void setVersion(Integer version) {
        log.debug("Entering setVersion(version = {})", version);
        this.version = version;
        log.debug("Exiting setVersion()");
    }

    
    
    /**
     * Gets the {@link DigitalRecord} that is associated with this 
     * RightsStatement.
     * 
     * @return The {@link DigitalRecord} that is associated with this 
     * RightsStatement.
     */
    public DigitalRecord getDigitalRecord() {
        log.debug("Entering getDigitalRecord()");
        log.debug("Exiting getDigitalRecord(): {}", this.digitalRecord);
        return this.digitalRecord;
    }

    
    
    
    /**
     *  Assists in implementing Object.toString() methods using reflection.
     *  This class uses reflection to determine the fields to append. Because 
     *  these fields are usually private, the class changes the visibility of 
     *  the fields. This will fail under a security manager,
     *  unless the appropriate permissions are set up correctly. 
     */
    @Override
    public String toString() {
        log.debug("Entering toString()");
        String toString = ReflectionToStringBuilder.toString(this,
                ToStringStyle.SHORT_PREFIX_STYLE);
        log.debug("Exiting toString(): {}", toString);
        return toString;
    }
    
    /**
     * Sets the logger for this class.
     * 
     * @param log The logger for this class.
     */
    @AutowiredLogger
    public void setLog(Logger log) {
        this.log = log;
    }
}
