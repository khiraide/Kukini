package gov.hawaii.digitalarchives.hida.core.model.digitalobject;

import java.io.Serializable;
import java.util.List;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.PersistenceContext;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.validation.constraints.NotNull;

import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.slf4j.Logger;
import org.springbyexample.util.log.AutowiredLogger;
import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.util.Assert;


/**
 * Model class of a format registry entry.
 * <p>
 * Class for encapsulating information about a file format 
 * identifier, such as a PRONOM id.  
 * 
 * @author Dongie Agnir
 * @author Keone Hiraide
 */
@Entity
@Configurable
@Table(name = "FORMAT_REGISTRY_ENTRY")
public class FormatRegistryEntry implements Serializable {
	
	/**
	 * Autogenerated for this entity to be serializable. Implementing
	 * Serializable isn't strictly necessary as far as the JPA specification
	 * is concerned. However, it is needed if you're going to use caching or
	 * EJB remoting, both of which require objects to be Serializable.
	 * Caching is a key component in achieving optimal performance in any
	 * JPA application, so implementing the Serializable interface is a good
	 * habit to adopt. Note: This was taken from the book titled, 
	 * "Spring Persistence with Hibernate", 2010, Fisher and Murphy. 
	 */
	private static final long serialVersionUID = 1100115405881190882L;

	/**
	 * The Name of the registry that assigned this entry.
	 */
	@Column(name="ASSIGNING_REGISTRY")
	private String assigningRegistry;
	
	/**
	 * An {@link EntityManager} instance is associated with a persistence 
	 * context. A persistence context is a set of entity instances in which 
	 * for any persistent entity identity there is a unique entity instance. 
	 * Within the persistence context, the entity instances and their life cycle 
	 * are  managed. The EntityManager API is used to create and remove 
	 * persistent entity instances, to find  entities by their primary key, 
	 * and to query over entities. As long as an object is attached to an 
	 * EntityManager, all changes to the object will be synchronized with 
	 * the database automatically (Meaning that this object is attached to the
	 * 'persistence context'). 
	 */
	@PersistenceContext
    transient EntityManager entityManager;
	
	/** Autowired logger to log this class */
    private transient Logger log = null;
    
	/**
	 * The name of the file format that this entry identifies.
	 */
	@Column(name="FORMAT_NAME")
	private String formatName;
	
	/**
	 * The version of the format that this entry identifies.
	 */
	@Column(name="FORMAT_VERSION")
	private String formatVersion;
	
	/**
	 * Primary key id of this FormatRegistryEntry class.
	 */
	@Id
    @NotNull
    @Column(name="FORMAT_REGISTRY_ENTRY_ID", unique = true)
	private String primaryId;
	
	/**
	 * Specifies the version field or property of an entity class that serves 
	 * as its optimistic lock value. The version is used to ensure 
	 * integrity when performing the merge operation and for optimistic 
	 * concurrency control. 
	 */
	@Version
    @Column(name = "VERSION")
    private Integer version;
	
	
	
	/**
     * Oracle specifications state that the class must have a public 
     * or protected, no-argument constructor. The class may have other 
     * constructors. 
     * http://docs.oracle.com/javaee/7/tutorial/doc/persistence-intro001.htm
     */
	public FormatRegistryEntry() {
	        
	}
	
	
	
	/**
	 * Creates a FormatRegistryEntry instance and ensures that its' 
	 * values are not null.
	 * 
	 * @param primaryId          The primary Id of this FormatRegistryEntry.
	 * @param assigningRegistry  The Name of the registry that assigned 
	 *                           this entry.
	 * @param formatName         The name of the file format that this entry 
	 *                           identifies.
	 * @param formatVersion      The version of the format that this entry
	 *                           identifies.
	 */
	public FormatRegistryEntry(final String primaryId, final String assigningRegistry, 
			 final String formatName, final String formatVersion) {
	    
		Assert.notNull(primaryId, "primaryId cannot be null");
		Assert.hasLength(primaryId, "primaryId cannot be empty");
		
		Assert.notNull(assigningRegistry, "assigningRegistry cannot be null");
		Assert.hasLength(assigningRegistry, "assigningRegistry cannot be empty");
		
		Assert.notNull(formatName, "formatName cannot be null");
		Assert.hasLength(formatName, "formatName cannot be empty");
		
		Assert.notNull(formatVersion, "formatVersion cannot be null");
		Assert.hasLength(formatVersion, "formatVersion cannot be empty");
		
		this.primaryId = primaryId;
		this.assigningRegistry = assigningRegistry;
		this.formatName = formatName;
		this.formatVersion = formatVersion;
	}

	/**
     * A new entity manager is created for every persistence related function. 
     * This pattern is called an “entitymanger-per-request” pattern. 
     * In this model, a request from the client is sent to the server 
     * (where the JPA persistence layer runs), a new EntityManager is opened, 
     * and all database operations are executed in this unit of work. Once the 
     * work has been completed (and the response for the client has been
     * prepared), the persistence context is flushed and closed, as well 
     * as the entity manager object. You would also use a single database 
     * transaction to serve the clients request. The relationship between 
     * the two is one-to-one and this model is a perfect fit for many 
     * applications.
     *  
     *  http://docs.jboss.org/hibernate/entitymanager/
     *  
     * @return A new EntityManager to do database operations.
     * 
     * 
     */
    public static final EntityManager entityManager() {
        staticMethodLogger().debug("Entering entityManager()");
        EntityManager em = new FormatRegistryEntry().entityManager;
        String errorMessage = "Throwing IllegalStateException in "
                + "entityManager(): 'Entity manager has not been injected "
            + "(is the Spring Aspects JAR configured as an AJC/AJDT aspects library?'";
        
        if (em == null)  {
            staticMethodLogger().error(errorMessage);
            throw new IllegalStateException(errorMessage);
        }
        
        staticMethodLogger().debug("Exiting entityManager(): {}", em);
        return em;
    }
    
    /**
     * Used to log static methods of this class. Since
     * Autowired logger cannot be "static", this method allows an 
     * Autowired Logger to be used within static methods.
     * 
     * @return A new logger to do logging operations.
     */
    private static final Logger staticMethodLogger() {
        Logger log = new FormatRegistryEntry().log;
        if (log == null) {
            throw new IllegalStateException("AutowiredLogger has not been"
                    + " injected!");
        }
        return log;
    }
	
	/**
	 * Gets the amount of FormatRegistryEntry objects that are currently 
	 * in the database.
	 * 
	 * @return The amount of FormatRegistryEntry objects that are 
	 *         currently in the database.
	 */
	public static long countFormatRegistryEntries() {
	    staticMethodLogger().debug("Entering countFormatRegistryEntries()");
        long count = entityManager().createQuery("SELECT COUNT(o) FROM FormatRegistryEntry o",
                Long.class).getSingleResult();
        staticMethodLogger().debug("Exiting countFormatRegistryEntries(): {}", count);
        return count;
    }
	
	/**
	 * Gets all the FormatRegistryEntry objects from the database 
	 * and puts them in a collection. 
	 * 
	 * @return The collection of FormatRegistryEntries that are 
	 *         in the database.
	 */
	public static List<FormatRegistryEntry> findAllFormatRegistryEntries() {
	    staticMethodLogger().debug("Entering findAllFormatRegistryEntries()");
        List<FormatRegistryEntry> formatRegistryEntries = entityManager()
                .createQuery("SELECT o FROM FormatRegistryEntry o", FormatRegistryEntry.class)
                .getResultList();
        staticMethodLogger().debug("Exiting findAllFormatRegistryEntries(): {}", 
                formatRegistryEntries);
        return formatRegistryEntries;
    }
	
	/**
	 * Gets a FormatRegistryEntry from the database according to its Id.
	 * 
	 * @param primaryId   The primary key of a FormatRegistryEntry.
	 * @return     The FormatRegistryEntry associated with the primaryId that 
	 *             was passed in or null if not found.
	 */
	public static FormatRegistryEntry findFormatRegistryEntry(String primaryId) {
	    staticMethodLogger().debug("Entering findFormatRegistryEntry(primaryId = {})", primaryId);
	    
        if (primaryId == null || primaryId.length() <= 0) {
            staticMethodLogger().debug("Exiting findFormatRegistryEntry(): null)");
            return null;
        }
        FormatRegistryEntry formatRegistryEntry = entityManager()
                .find(FormatRegistryEntry.class, primaryId);
        
        staticMethodLogger().debug("Exiting findFormatRegistryEntry(): {})", formatRegistryEntry);
        return formatRegistryEntry;
    }
	
	/**
	 * Gets a certain subset of FormatRegistryEntries based 
	 * on the range desired.
	 * 
	 * @param firstResult  The beginning of the range of values.
	 * @param maxResults   The last element of the range of values.
	 * @return             The collection of FormatRegistryEntries based 
	 *                     on the range desired. 
	 */
	public static List<FormatRegistryEntry> 
	findFormatRegistryEntryEntries(int firstResult, int maxResults) {
	    staticMethodLogger().debug("Entering findFormatRegistryEntryEntries(firstResult = {}, " +
	    		"maxResults = {})",
                firstResult, maxResults);
        
        List<FormatRegistryEntry> formatRegistryEntries = entityManager()
                .createQuery("SELECT o FROM FormatRegistryEntry o", FormatRegistryEntry.class)
                .setFirstResult(firstResult).setMaxResults(maxResults)
                .getResultList();
        
        staticMethodLogger().debug("Exiting findFormatRegistryEntryEntries(): {}", 
                formatRegistryEntries);
        return formatRegistryEntries;
    }
	
	
	
	/**
	 * @return The Name of the registry that assigned this entry.
	 */
	public String getAssigningRegistry() {
	    log.debug("Entering getAssigningRegistry()");
	    log.debug("Exiting getAssigningRegistry(): {}", this.assigningRegistry);
		return this.assigningRegistry;
	}

	/**
	 * @return The name of the file format that this entry identifies.
	 */
	public String getFormatName() {
	    log.debug("Entering getFormatName()");
	    log.debug("Exiting getFormatName(): {}", this.formatName);
		return this.formatName;
	}
	
	
	/**
	 * @return The version of the format that this entry identifies.
	 */
	public String getFormatVersion() {
	    log.debug("Entering getFormatVersion()");
	    log.debug("Exiting getFormatVersion(): {}", this.formatVersion);
		return this.formatVersion;
	}

	
	
	/**
	 * @return The ID of this entry within the registry given by 
	 * {@link #getAssigningRegistry()}.
	 */
	public String getPrimaryId() {
	    log.debug("Entering getPrimaryId()");
	    log.debug("Exiting getPrimaryId(): {}", this.primaryId);
		return this.primaryId;
	}

	
	
	/**
	 * Gets the version of this FormatRegistryEntry.
	 * 
	 * @return The version of this FormatRegistryEntry.
	 */
	public Integer getVersion() {
	    log.debug("Entering getVersion()");
	    log.debug("Exiting getVersion(): {}", this.version);
        return this.version;
    }

	
	
	/**
	 * Sets the version of this FormatRegistryEntry.
	 * 
	 * @param version The version of this FormatRegistryEntry.
	 */
	public void setVersion(Integer version) {
	    log.debug("Entering setVersion(version = {})", version);
        this.version = version;
        log.debug("Exiting setVersion()");
    }
	
	
	
	/**
	 *  Assists in implementing Object.toString() methods using reflection.
	 *  This class uses reflection to determine the fields to append. Because 
	 *  these fields are usually private, the class changes the visibility of 
	 *  the fields. This will fail under a security manager,
	 *  unless the appropriate permissions are set up correctly. 
	 */
	@Override
	public String toString() {
        log.debug("Entering toString()");
        String toString = ReflectionToStringBuilder.toString(this,
                ToStringStyle.SHORT_PREFIX_STYLE);
        log.debug("Exiting toString(): {}", toString);
        return toString;
    }
	
	/**
     * Sets the logger for this class.
     * 
     * @param log The logger for this class.
     */
    @AutowiredLogger
    public void setLog(Logger log) {
        this.log = log;
    }
}
