package gov.hawaii.digitalarchives.hida.core.model.digitalobject;
import gov.hawaii.digitalarchives.hida.core.model.DigitalSignature;
import gov.hawaii.digitalarchives.hida.core.model.HashValue;

import java.io.Serializable;
import java.util.List;

import javax.persistence.Entity;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;

import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.transaction.annotation.Transactional;


/**
 * A representation of a file within an archive.  Along with the raw byte 
 * stream that comprises the file, this abstract class also exposes additional 
 * information useful for archival purposes.
 *
 * @author Dongie Agnir
 */
@Configurable
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class FileObject extends DigitalObject implements Serializable  {
	
	/**
	 * Autogenerated for this entity to be serializable. Implementing
	 * Serializable isn't strictly necessary as far as the JPA specification
	 * is concerned. However, it is needed if you're going to use caching or
	 * EJB remoting, both of which require objects to be Serializable.
	 * Caching is a key component in achieving optimal performance in any
	 * JPA application, so implementing the Serializable interface is a good
	 * habit to adopt. Note: This was taken from the book titled, 
	 * "Spring Persistence with Hibernate", 2010, Fisher and Murphy. 
	 */
	private static final long serialVersionUID = -6790126501686124679L;



	/**
	 * Gets the amount of FileObject objects that are currently 
	 * in the database.
	 * 
	 * @return The amount of FileObject objects that are 
	 *         currently in the database.
	 */
	public static long countFileObjects() {
		staticMethodLogger().debug("Entering countFileObjects()");
		long count = entityManager().createQuery("SELECT COUNT(o) FROM FileObject o",
				Long.class).getSingleResult();
		staticMethodLogger().debug("Exiting countFileObjects(): {}", count);
		return count;
    }
	
	/**
	 * Gets all the FileObject objects from the database 
	 * and puts them in a collection. 
	 * 
	 * @return The collection of FileObjects that are 
	 *         in the database.
	 */
	public static List<FileObject> findAllFileObjects() {
		staticMethodLogger().debug("Entering findAllFileObjects()");
		List<FileObject> fileObjects = entityManager().createQuery("SELECT o FROM FileObject o",
				FileObject.class).getResultList();
		staticMethodLogger().debug("Exiting findAllFileObjects(): {}", fileObjects);
		return fileObjects;
    }
	
	/**
	 * Queries for a FileObject based on its primaryId.
	 * 
	 * @param primaryId The String id associated with this FileObject.
	 * @return The FileObject associated with the primaryId that was
     *             passed in or null if not found.
	 */
	public static FileObject findFileObject(String primaryId) {
		staticMethodLogger().debug("Entering findFileObject(primaryId = {})", primaryId);
		if (primaryId == null || primaryId.length() <= 0) {
		    staticMethodLogger().debug("Exiting findFileObject(): null");
			return null;
		}
		FileObject fileObject = entityManager().find(FileObject.class, primaryId);
		staticMethodLogger().debug("Exiting findFileObject(): {})", fileObject);
		return fileObject;
    }
	
	/**
	 * Gets a certain subset of FileObjects based 
	 * on the range desired.
	 * 
	 * @param firstResult  The beginning of the range of values.
	 * @param maxResults   The last element of the range of values.
	 * @return             The collection of FileObjects based 
	 *                     on the range desired. 
	 */
	public static List<FileObject> findFileObjectEntries(int firstResult, int maxResults) {
		staticMethodLogger().debug("Entering findFileObjectEntries(firstResult = {})", 
		        firstResult);
		List<FileObject> fileObjects = entityManager()
				.createQuery("SELECT o FROM FileObject o", FileObject.class)
				.setFirstResult(firstResult).setMaxResults(maxResults)
				.getResultList();
		staticMethodLogger().debug("Exiting findFileObjectEntries(): {}", fileObjects);
		return fileObjects;
    }
	
	/**
	 * Add a significant {@link Property} to this FileObject.
	 * 
	 * @param p The significant Property to add.
	 */
	public abstract void addSignificantProperty(Property p);
	
	/**
	 * Add an entry indicating where this particular digital object is stored
	 * within the system.  Must not be null.
	 *
	 * @param entry The entry to add.  Must not be {@code null}.
	 */
	public abstract void addStorageInformation(StorageEntry entry);
	
	/**
	 * @return The digital signature for the file.  {@code null} if it is not
	 * available.
	 */
	public abstract DigitalSignature getDigitalSignature();
	
	/**
	 * @return The the path to the actual file this Digital Object represents.
	 */
	public abstract String getFilePath();
	
	/**
	 * Set the path on the filesystem to the actual file this Digital Object
	 * represents.
	 *
	 * @param file The path to the file.
	 */
	public abstract void setFilePath(String file);

	/**
	 * @return Information relating to the file's format.
	 */
	public abstract FormatRegistryEntry getFormatInformation();

	
	/**
	 * @return The hash value of this object.
	 */
	public abstract HashValue getHash();

	/**
	 * @return The list of significant properties for this FileObject.
	 */
	public abstract List<Property> getSignificantProperties();
	
	/**
	 * @return The size of the digital object in bytes. 
	 */
	public abstract long getSize();

	
	
	/**
	 * @return The list of storage entries for the digital object.  This is a
	 * defensive copy, and is not backed by object's internal copy of the
	 * list.
	 */
	public abstract List<StorageEntry> getStorageInformation();

	
	
	/**
	 * If this object is detached, the merge() method will merge them back into
	 * the EntityManager to become managed again. Note that changes to detached
	 * entity objects are not stored in the database.
	 * 
	 * @return The merged FileObject.
	 */
	@Override
	@Transactional
    public FileObject merge() {
		log.debug("Entering merge()");
		if (this.entityManager == null)
			this.entityManager = entityManager();
		FileObject merged = this.entityManager.merge(this);
		this.entityManager.flush();
		log.debug("Exiting merge(): {}", merged);
		return merged;
    }

	
	
	/**
	 * Set the digital signature of the file.
	 * 
	 * @param signature The digital signature of the file.
	 */
	public abstract void setDigitalSignature(DigitalSignature signature);

	
	
	/**
	 * Set the information about the file's format.
	 * 
	 * @param The information for the file's format.
	 */
	public abstract void setFormatInformation(FormatRegistryEntry formatInfo);

	
	
	/**
	 * Set the hash value of this digital object.
	 * 
	 * @param hash The byte array containing the hash value of the digital 
	 * object.
	 * @param algorithm The algorithm used to compute the hash value.
	 */
	public abstract void setHash(final byte[] hash, String algorithm);
}
