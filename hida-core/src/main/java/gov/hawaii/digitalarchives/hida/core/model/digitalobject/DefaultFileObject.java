package gov.hawaii.digitalarchives.hida.core.model.digitalobject;
import gov.hawaii.digitalarchives.hida.core.model.DigitalSignature;
import gov.hawaii.digitalarchives.hida.core.model.HashValue;
import gov.hawaii.digitalarchives.hida.core.model.record.Representation;

import java.io.Serializable;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.JoinColumn;
import javax.persistence.MapKey;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Table;

import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.transaction.annotation.Transactional;



/**
 * This class provides a default implementation for the {@link FileObject}
 * abstract class.
 * <p>
 * This class only supports files available on the local filesystem.
 *
 *
 */
//TODO:
//Override equals() and hashCode().
@Configurable
@Entity
@Table(name = "DEFAULT_FILE_OBJECT")
public class DefaultFileObject extends FileObject implements Serializable {
    
	/**
	 * Autogenerated for this entity to be serializable. Implementing
	 * Serializable isn't strictly necessary as far as the JPA specification
	 * is concerned. However, it is needed if you're going to use caching or
	 * EJB remoting, both of which require objects to be Serializable.
	 * Caching is a key component in achieving optimal performance in any
	 * JPA application, so implementing the Serializable interface is a good
	 * habit to adopt. Note: This was taken from the book titled, 
	 * "Spring Persistence with Hibernate", 2010, Fisher and Murphy. 
	 */
	private static final long serialVersionUID = -1365935728319731114L;

	/**
     * A DigitalSignature foreign key will be stored in this 
     * DefaultFileObject object/table.
     */
    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name="DIGITAL_SIGNATURE_ID",insertable=true,
    updatable=true,nullable=false,unique=true)
    private DigitalSignature digitalSignature;
    
    /**
     * The underlying file this FileObject represents.
     */
    @Column(name="FILE_PATH", nullable=false)
  	private String filePath;
    
  	/**
  	 * File format information.
  	 * <p>
     * A FormatRegistryEntry foreign key will be stored in this 
     * DefaultFileObject object/table.
     */
    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name = "FORMAT_INFORMATION_ID", insertable = true,
    updatable = true, nullable = false, unique = false)
    private FormatRegistryEntry formatInformation;
    
    /**
     * A HashValue foreign key will be stored in this DefaultFileObject
     * object/table.
     */
    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name="HASH_VALUE",insertable=true,
    updatable=true, nullable=false, unique=true)
    private HashValue hash;
    
    

    /**
     * The ID of the {@link Representation} this object belongs to.
     */
    @Column(name="REPRESENTATION_ID")
	private String representationId;
	
	/**
     * A join table will be created, holding a foreign key representing 
     * a DefaultFileObject and a foreign key representing a Property. 
     * The significantProperties value will have its own column in 
     * this join table.  
     */
	@OneToMany(mappedBy="digitalObject", cascade=CascadeType.ALL)
	@MapKey
    private Map<String,Property> significantProperties = new HashMap<String, Property>();
	
	/**
	 * The ID of the record this object belongs to.
	 */
	@Column(name="SOURCE_OBJECT_ID")
	private String sourceObjectId;
	
	/**
     * A DefaultFileObject object has many StorageEntries.
     * A DefaultFileObject object's primary key will be used as as a foreign key
     * in the StorageEntry's object/table.
     */
	@OneToMany(cascade=CascadeType.ALL, mappedBy="digitalObject")
    private List<StorageEntry> storageInformation = new ArrayList<StorageEntry>();

	
	/**
	 * Gets the amount of DefaultFileObject objects that are currently 
	 * in the database.
	 * 
	 * @return The amount of DefaultFileObject objects that are 
	 *         currently in the database.
	 */
	public static long countDefaultFileObjects() {
		staticMethodLogger().debug("Entering countDefaultFileObjects()");
		long count = entityManager().createQuery("SELECT COUNT(o) FROM DefaultFileObject o",
				Long.class).getSingleResult();
		staticMethodLogger().debug("Exiting countDefaultFileObjects(): {}", count);
		return count;
    }
    
    /**
	 * Gets all the DefaultFileObject objects from the database 
	 * and puts them in a collection. 
	 * 
	 * @return The collection of DefaultFileObjects that are 
	 *         in the database.
	 */
	public static List<DefaultFileObject> findAllDefaultFileObjects() {
		staticMethodLogger().debug("Entering findAllDefaultFileObjects()");
		List<DefaultFileObject> defaultFileObjects = entityManager()
				.createQuery("SELECT o FROM DefaultFileObject o",
				DefaultFileObject.class).getResultList();
		staticMethodLogger().debug("Exiting findAllDefaultFileObjects(): {}", defaultFileObjects);
		return defaultFileObjects;
    }
    
	/**
	 * Gets a DefaultFileObject from the database according to its Id.
	 * 
	 * @param primaryId   The primary key of a DefaultFileObject.
	 * @return     The DefaultFileObject associated with the primaryId that was
	 * 		       passed in or null if not found.
	 */
	public static DefaultFileObject findDefaultFileObject(String primaryId) {
		staticMethodLogger().debug("Entering findDefaultFileObject(primaryId = {})", primaryId);
		if (primaryId == null || primaryId.length() <= 0) {
		    staticMethodLogger().debug("Exiting findDefaultFileObject(): null)");
			return null;
		}
		DefaultFileObject defaultFileObject = entityManager().
		        find(DefaultFileObject.class, primaryId);
		staticMethodLogger().debug("Exiting findDefaultFileObject(): {})", defaultFileObject);
		return defaultFileObject;
    }
    
  	/**
	 * Gets a certain subset of DefaultFileObjects based 
	 * on the range desired.
	 * 
	 * @param firstResult  The beginning of the range of values.
	 * @param maxResults   The last element of the range of values.
	 * @return             The collection of DefaultFileObjects based 
	 *                     on the range desired. 
	 */
	public static List<DefaultFileObject> 
	findDefaultFileObjectEntries(int firstResult, int maxResults) {
	    
		staticMethodLogger().debug("Entering findDefaultFileObjectEntries(firstResult = {})",
		        firstResult);
		
		List<DefaultFileObject> defaultFileObjects = entityManager()
				.createQuery("SELECT o FROM DefaultFileObject o", DefaultFileObject.class)
				.setFirstResult(firstResult).setMaxResults(maxResults)
				.getResultList();
		
		staticMethodLogger().debug("Exiting findDefaultFileObjectEntries(): {}",
		        defaultFileObjects);
		return defaultFileObjects;
    }

	
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void addSignificantProperty(Property p) {
		log.debug("Entering addSignificantProperty(p = {})", p);
		if (p == null) {
		    log.error("Throwing IllegalArgumentException in "
		    		+ "addSignificantProperty(p = {}). property cannot be null.");
			throw new IllegalArgumentException("property cannot be null.");
		}
		significantProperties.put(p.getName(), p);
		log.debug("Exiting addSignificantProperty()");
	}

	
	
	/**
     * {@inheritDoc}
     */
	@Override
	public void addStorageInformation(StorageEntry entry) {
	    log.debug("Entering addSignificantProperty(entry = {})", entry);
		this.storageInformation.add(entry);
	    log.debug("Exiting addStorageInformation()");
	}

	
	
	/**
     * {@inheritDoc}
     */
	@Override
	public DigitalSignature getDigitalSignature() {
	    log.debug("Entering addSignificantProperty()");
		log.debug("Exiting getDigitalSignature(): {}", this.digitalSignature);
        return this.digitalSignature;
    }
	
	/**
	 * @return The path of type Path to the actual file this
	 *         Digital Object represents or null if the filePath has not been
	 *         set.
	 */
	@Override
	public String getFilePath() {
		log.debug("Entering getFilePath()");
		log.debug("Exiting getFilePath(): {}", filePath);
        return filePath;
    }
	
	/**
     * {@inheritDoc}
     */
	@Override
	public FormatRegistryEntry getFormatInformation() {
	    log.debug("Entering getFormatInformation()");
		log.debug("Exiting getFormatInformation(): {}", formatInformation);
        return this.formatInformation;
    }

	
	
	/**
     * {@inheritDoc}
     */
	@Override
	public HashValue getHash() {
	    log.debug("Entering getHash()");
		log.debug("Exiting getHash(): {}", hash);
        return this.hash;
    }

	
	
    /**
     * {@inheritDoc}
     */
	public String getRepresentationId() {
		log.debug("Entering getRepresentationId()");
		log.debug("Exiting getRepresentationId(): {}", representationId);
		return representationId;
	}

	
	
	/**
     * {@inheritDoc}
     */
	@Override
	public List<Property> getSignificantProperties() {
	    log.debug("Entering getSignificantProperties()");
		log.debug("Exiting getSignificantProperties(): {}", significantProperties.values());
		return new ArrayList<Property>(this.significantProperties.values());
    }

	
	
	@Override
	public long getSize() {
	    log.debug("Entering getSize()");
        if (filePath != null) {
            Path filePath = Paths.get(this.getFilePath());
            log.debug("Exiting getSize(): {}", filePath.toFile().length());
            return filePath.toFile().length();
        }
        log.debug("Exiting getSize(): {}", 0L);
        return 0L;
	}

	
	
	/**
     * {@inheritDoc}
     */
	@Override
	public String getSourceObjectId() {
		log.debug("Entering getSourceObjectId()");
		log.debug("Exiting getSourceObjectId(): {}", sourceObjectId);
		return sourceObjectId;
    }

	
	
	/**
     * {@inheritDoc}
     */
	@Override
	public List<StorageEntry> getStorageInformation() {
	    log.debug("Entering getStorageInformation()");
		log.debug("Exiting getStorageInformation(): {}", this.storageInformation);
        return new ArrayList<StorageEntry>(this.storageInformation);
    }

	
	
	/**
	 * If this object is detached, the merge() method will merge them back into
	 * the EntityManager to become managed again. Note that changes to detached
	 * entity objects are not stored in the database.
	 * 
	 * @return The merged DefaultFileObject.
	 */
	@Override
	@Transactional
    public DefaultFileObject merge() {
		log.debug("Entering merge()");
        if (this.entityManager == null) 
        	this.entityManager = entityManager();
        DefaultFileObject merged = this.entityManager.merge(this);
        this.entityManager.flush();
        log.debug("Exiting merge(): {}", merged);
        return merged;
    }

	
	
	/**
     * {@inheritDoc}
     */
	@Override
	public void setDigitalSignature(DigitalSignature digitalSignature) {
		log.debug("Entering setDigitalSignature(digitalSignature = {})", digitalSignature);
        this.digitalSignature = digitalSignature;
        log.debug("Exiting setDigitalSignature()");
    }

	
	
	/**
     * {@inheritDoc}
     */
	@Override
	public void setFilePath(String filePath) {
		log.debug("Entering setFilePath(filePath = {})", filePath);
        this.filePath = filePath;
        log.debug("Exiting setFilePath()");
    }

	

	/**
     * {@inheritDoc}
     */
	@Override
	public void setFormatInformation(FormatRegistryEntry formatInformation) {
		log.debug("Entering setFormatInformation(formatInformation = {})", formatInformation);
        this.formatInformation = formatInformation;
        log.debug("Exiting setFormatInformation()");
    }

	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setHash(final byte[] hash, final String algorithm) {
	    log.debug("Entering setHash(hash = {}, algorithm = {})", hash, algorithm);
		this.hash = new HashValue(algorithm, hash);
		log.debug("Exiting setHash()");
	}
	

	/**
     * {@inheritDoc}
     */
	@Override
	public void setRepresentationId(final String representationId) {
		log.debug("Entering setRepresentationId(representationId = {})", representationId);
        this.representationId = representationId;
        log.debug("Exiting setRepresentationId()");
    }
	
	
	
	/**
     * {@inheritDoc}
     */
	@Override
	public void setSourceObjectId(final String sourceObjectId) {
		log.debug("Entering setSourceObjectId(sourceObjectId = {})", sourceObjectId);
        this.sourceObjectId = sourceObjectId;
        log.debug("Exiting setSourceObjectId()");
    }
}
