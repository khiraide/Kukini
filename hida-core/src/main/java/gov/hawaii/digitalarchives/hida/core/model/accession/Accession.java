package gov.hawaii.digitalarchives.hida.core.model.accession;

import gov.hawaii.digitalarchives.hida.core.exception.HidaIdSyntaxException;
import gov.hawaii.digitalarchives.hida.core.model.Event;
import gov.hawaii.digitalarchives.hida.core.model.Eventful;
import gov.hawaii.digitalarchives.hida.core.model.record.Agent;
import gov.hawaii.digitalarchives.hida.core.model.record.ProducerInfo;
import gov.hawaii.digitalarchives.hida.core.model.rtp.RecordsTransmittalPlan;
import gov.hawaii.digitalarchives.hida.core.util.Lists;

import java.io.Serializable;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.MapKeyColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.PersistenceContext;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.persistence.Version;
import javax.validation.constraints.NotNull;

import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.slf4j.Logger;
import org.springbyexample.util.log.AutowiredLogger;
import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;

/**
 * This is the Accession data model. It represents the transfer that is sent to
 * HiDA by an Agency. The official HiDA lexicon describes an Accession as "A
 * body of records formally accepted into custody as a unit at a single time.
 * (archival theory)."
 * <p>
 * A note on the manifest ({@link #getManifest()}). It is represented as a list
 * of {@link ManifestDrive} objects. These "drives" represent drives on the
 * transferer's machine, where the files packaged into the Submission
 * Information Package were taken from.
 * 
 * @author Dongie Agnir
 */
@Configurable
@Entity
@Table(name ="ACCESSION")
@JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class, property = "@id")
@JsonAutoDetect(fieldVisibility = Visibility.ANY, getterVisibility = Visibility.NONE, 
setterVisibility = Visibility.NONE, isGetterVisibility = Visibility.NONE)
public class Accession implements Serializable , Eventful {
    
    /**
     * Autogenerated for this entity to be serializable. Implementing
     * Serializable isn't strictly necessary as far as the JPA specification
     * is concerned. However, it is needed if you're going to use caching or
     * EJB remoting, both of which require objects to be Serializable.
     * Caching is a key component in achieving optimal performance in any
     * JPA application, so implementing the Serializable interface is a good
     * habit to adopt. Note: This was taken from the book titled, 
     * "Spring Persistence with Hibernate", 2010, Fisher and Murphy. 
     */
    private static final long serialVersionUID = 2974166699122161489L;

    /**
     * The primary key of an Accession.
     */
    @Id
    @NotNull
    @Column(name = "ACCESSION_ID", unique = true)
    private String primaryId;

    /**
     * An Agent foreign key representing a creator will be stored in an
     * Accession object/table.
     */
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name="CREATOR_ID")
    private Agent creator;

    /**
     * An Agent foreign key representing a preserver will be stored in an
     * Accession object/table.
     */
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name="PRESERVER_ID")
    private Agent preserver;

    /**
     * The accession number for this Accession.
     */
    @Column(name = "ACCESSION_NUMBER")
    private String accessionNumber;

    /**
     * The date that this {@code Accession} was created on.
     */
    @Column(name = "ACCESSION_CREATION_DATE")
    private Date accessionCreationDate;

    /**
     * The date this {@code Accession} was received on.
     */
    @Column(name = "ACCESSION_RECEIVE_DATE")
    private Date accessionReceiveDate;

    /**
     * A ProducerInfo foreign key will be stored in this Accession 
     * object/table.
     */
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name="PRODUCER_INFO_ID")
    private ProducerInfo producerInfo;

    // private final AccessionManifest manifest;

    /**
     * The name of the person who initiated the transfer of this
     * {@code Accession} the the Digital Archives.
     */
    @Column(name = "TRANSFERER_NAME")
    private String transfererName;

    /**
     * A description the method by which this {@code Accession} was transferred
     * to the Digital Archives.
     */
    @Column(name = "TRANSFERER_METHOD")
    private String transferMethod;

    /**
     * The ID of the {@link RecordsTransmittalPlan} that is associated this
     * {@code Accession}.
     */
    @Column(name = "RTP_ID")
    private String rtpId;

    /**
     * The ID of the {@code Parser} capable of parsing the index of this type 
     * of {@code Accession}.
     */
    @Column(name = "INDEX_PARSER_ID")
    private String indexParserId;

    /**
     * An Accession object has many ManiFestDrives. An Accession object's
     * primary key will be used as as a foreign key in the ManifestDrive's
     * object/table.
     */
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "accession")
    private List<ManifestDrive> manifest = Lists.newArrayList();
    
    /**
     * Captures the name of system, if applicable, from which the records
     * were extracted.
     */
    @Column(name = "SYSTEM_CREATOR")
    private String systemCreator;

    /**
     * String representing the Accession's path.
     */
    @Column(name = "ACCESSION_PATH")
    private String accessionPath;

    /**
     * Holds machine information from the
     * user's machine. For example: ip address and mac address.
     */
    @ElementCollection
    @JoinTable(name="MACHINE_INFO", joinColumns=@JoinColumn(name="ACCESSION_ID"))
    @MapKeyColumn (name="MACHINE_INFO_ID")
    @Column(name="MACHINE_INFO_VALUE")
    private Map<String, String> machineInfo;
    
    /**
     * Each stage generates events containing information of what happened to
     * the content of this accession.
     */
    @OneToMany(cascade = CascadeType.ALL)
    private Set<Event> events = new TreeSet<>();

    /**
     * Specifies the version field or property of an entity class that serves as
     * its optimistic lock value. The version is used to ensure integrity when
     * performing the merge operation and for optimistic concurrency control.
     */
    @Version
    @Column(name = "VERSION")
    private Integer version;
    
    /**
     * Indicates whether the bag associated with this Accession is valid.
     */
    @Transient
    private Boolean bagValid = null;
    
    /**
     * Indicates whether this Accession has been virus scanned, is virus clean,
     * or is not virus clean.
     */
    @Transient
    private Boolean virusClean = null;
    
    /**
     * Indicates whether the RTP for this accession has been validated.
     */
    @Transient
    private Boolean rtpValid = null;
    
    /** Indicates whether accession has been processed by records extractor. */
    @Transient
    private boolean recordsExtracted = false;
    
    /** Indicates how many records are part of this accession. */
    @Transient
    private int recordCount = 0;

    /**
     * An {@link EntityManager} instance is associated with a persistence
     * context. A persistence context is a set of entity instances in which for
     * any persistent entity identity there is a unique entity instance. Within
     * the persistence context,the entity instances and their life cycle are
     * managed. The EntityManager API is used to create and remove persistent
     * entity instances, to find entities by their primary key, and to query
     * over entities. As long as an object is attached to an EntityManager, all
     * changes to the object will be synchronized with the database
     * automatically (Meaning that this object is attached to the 'persistence
     * context').
     */
    @PersistenceContext
    transient EntityManager entityManager;
    
    /**
     * AutowiredLogger for logging purposes.
     */
    private transient Logger log = null;
    
    /**
     * Oracle specifications state that the class must have a public or
     * protected, no-argument constructor. The class may have other
     * constructors.
     * 
     * http://docs.oracle.com/javaee/7/tutorial/doc/persistence-intro001.htm
     */
    public Accession() {
        
    }
    
    /**
     * Construct a new instance of an Accession
     * with its primaryId.
     * 
     * @param primaryId The primaryId of this Accession.
     */
    public Accession(String primaryId) {
        this.primaryId = primaryId;
    }

    /**
     * @return The ID of this Accession.
     */
    public String getPrimaryId() {
        //log.debug("Entering getPrimaryId()");
        //log.debug("Exiting getPrimaryId(): {}", primaryId);
        return primaryId;
    }

    /**
     * @return The {@code Agent} responsible for creating this Accession.
     */
    public Agent getCreator() {
        //log.debug("Entering getCreator()");
        //log.debug("Exiting getCreator(): {}", creator);
        return creator;
    }

    /**
     * Set the {@code Agent} responsible for creating this Accession.
     * 
     * @param creator The creating Agent.
     */
    public void setCreator(final Agent creator) {
        //log.debug("Entering setCreator(creator = {})", creator);
        this.creator = creator;
        //log.debug("Exiting setCreator(creator)");
    }

    /**
     * @return The {@code Agent} responsible for preserving this Accession.
     */
    public Agent getPreserver() {
        //log.debug("Entering getPreserver()");
        //log.debug("Exiting getPreserver(): {}", preserver);
        return preserver;
    }

    /**
     * Set the {@code Agent} responsible for preserving this Accession.
     * 
     * @param preserver The preserving Agent.
     */
    public void setPreserver(final Agent preserver) {
        //log.debug("Entering setPreserver(preserver = {})", preserver);
        this.preserver = preserver;
        //log.debug("Exiting setPreserver()");
    }

    /**
     * @return The accession number in the form of a URI for this Accession or 
     *         null if the accession number for this Accession has not been 
     *         set.
     */
    public URI getAccessionNumber() {
        //log.debug("Entering getAccessionNumber()");
        if (accessionNumber == null || accessionNumber.length() <= 0) {
            //log.debug("Exiting getAccessionNumber(): null");
            return null;
        }
        URI accessionNumberURI = null;
        try {
            accessionNumberURI = new URI(accessionNumber);
        } catch (URISyntaxException e) {
            String errorMessage = "Badly formatted URI when accessionNumberURI was constructed" +
                    " for the getAccessionNumber() method in the Accession class.";
            log.error(errorMessage, e);
            throw new HidaIdSyntaxException(errorMessage, e);
        }
        //log.debug("Exiting getAccessionNumber(): {}", accessionNumberURI);
        return accessionNumberURI;
    }

    /**
     * Set the accession number for this Accession. It is used to identify it 
     * within the system for retrieval.
     * 
     * @param accessionNumber The accession number.
     */
    public void setAccessionNumber(final URI accessionNumber) {
        //log.debug("Entering setAccessionNumber(accessionNumber = {})", accessionNumber);
        if (accessionNumber == null) {
            this.accessionNumber = null;
        }
        else {
            this.accessionNumber = accessionNumber.toString();
        }
        //log.debug("Exiting setAccessionNumber()");
        
    }

    /**
     * @return the date that this {@code Accession} was created on.
     */
    public Date getAccessionCreationDate() {
        //log.debug("Entering getAccessionCreationDate()");
        if (this.accessionCreationDate != null) {
            Date accessionCreationDate = new Date(this.accessionCreationDate.getTime());
            //log.debug("Exiting getAccessionCreationDate(): {}", accessionCreationDate);
            return accessionCreationDate;
        }
            //log.debug("Exiting getAccessionCreationDate(): null");
            return null;
    }

    /**
     * Set the date this {@code Accession} was created on.
     * 
     * @param accessionCreationDate The date the accession was created.
     */
    public void setAccessionCreationDate(final Date accessionCreationDate) {
        //log.debug("Entering setAccessionCreationDate(accessionCreationDate = {})",
        //        accessionCreationDate);
        
        if (accessionCreationDate != null) {
            this.accessionCreationDate = new Date(accessionCreationDate.getTime());
        } else {
            this.accessionCreationDate = null;
        }
        
        //log.debug("Exiting setAccessionCreationDate()");
    }

    /**
     * @return The date this {@code Accession} was received on.
     */
    public Date getAccessionReceiveDate() {
        //log.debug("Entering getAccessionReceiveDate()");
        if (accessionReceiveDate != null) {
            Date accessionReceiveDate = new Date(this.accessionReceiveDate.getTime());
            //log.debug("Exiting getAccessionReceiveDate(): {}", accessionReceiveDate);
            return accessionReceiveDate;
        } else {
            //log.debug("Exiting getAccessionReceiveDate(): null");
            return null;
        }
    }

    /**
     * Set the date this {@code Accession} was received on.
     * 
     * @param accessionReceiveDate The date this {@code Accession} was received 
     *                             on.
     */
    public void setAccessionReceiveDate(final Date accessionReceiveDate) {
        //log.debug("Entering setAccessionReceiveDate(accessionReceiveDate = {})",
        //       accessionReceiveDate);
        if (accessionReceiveDate != null) {
            this.accessionReceiveDate = new Date(accessionReceiveDate.getTime());
        } else {
            this.accessionReceiveDate = null;
        }
        //log.debug("Exiting setAccessionReceiveDate()");
    }

    /**
     * @return Information about the producer of this {@code Accession}.
     */
    public ProducerInfo getProducerInfo() {
        //log.debug("Entering getProducerInfo()");
        //log.debug("Exiting getProducerInfo(): {}", producerInfo);
        return producerInfo;
    }

    /**
     * Set the information about the producer of this {@code Accession}.
     * 
     * @param producerInfo Information about the producer of this 
     *                     {@code Accession}.
     */
    public void setProducerInfo(final ProducerInfo producerInfo) {
        //log.debug("Entering setProducerInfo(producerInfo(producerInfo = {})", producerInfo);   
        this.producerInfo = producerInfo;
        //log.debug("Exiting setProducerInfo()");
    }

    /**
     * @return The name of the person who initiated the transfer of this
     *         {@code Accession} the the Digital Archives.
     */
    public String getTransfererName() {
        //log.debug("Entering getTransfererName()");
        //log.debug("Exiting getTransfererName(): {}", transfererName);
        return transfererName;
    }

    /**
     * Set the name of the person who initiated the transfer of this
     * {@code Accession} to the Digital Archives.
     * 
     * @param transfererName The name of the transferrer.
     */
    public void setTransfererName(final String transfererName) {
        //log.debug("Entering setTransfererName(transfererName = {})", transfererName);
        this.transfererName = transfererName;
        //log.debug("Exiting setTransfererName()");
    }

    /**
     * @return A description the method by which this {@code Accession} was
     *         transferred to the Digital Archives.
     */
    public String getTransferMethod() {
        //log.debug("Entering getTransferMethod()");
        //log.debug("Exiting setTransferMethod(): {}", transferMethod);
        return transferMethod;
        

    }

    /**
     * Set a description of the way this {@code Accession} was transferred to
     * the Digital Archives.
     * 
     * @param transferMethod The description of the transfer method.
     */
    public void setTransferMethod(final String transferMethod) {
        //log.debug("Entering setTransferMethod(transferMethod = {})", transferMethod);
        this.transferMethod = transferMethod;
        //log.debug("Exiting setTransferMethod()");
    }

    /**
     * @return The ID of the {@link RecordsTransmittalPlan} that is associated
     *         this {@code Accession}, or null if an rtpId has not been set for
     *         this class.
     */
    public String getRtpId() {
        //log.debug("Entering getRtpId()");
        //log.debug("Exiting getRtpId(): {}", rtpId);
        return rtpId;
    }

    /**
     * Set the ID of the {@link RecordsTransmittalPlan} that is associated with
     * this {@code Accession}.
     * 
     * @param rtpId The ID of the associated {@code Accession}.
     */
    public void setRtpId(final String rtpId) {
        //log.debug("Entering setRtpId(rtpId = {})", rtpId);
        this.rtpId = rtpId;
        //log.debug("Exiting setRtpId()");
    }

    /**
     * @return The ID of the {@code Parser} capable of parsing the index of
     * this Accession.
     * */
    public String getIndexParserId() {
        //log.debug("Entering getIndexParserId()");
        //log.debug("Exiting getIndexParserId(): {}", indexParserId);
        return indexParserId;
    }

    /**
     * Set the ID of the {@code Parser} capable of parsing the index of this
     * type of @code Accession}.
     * 
     * @param indexParserId The ID of the {@code Parser}.
     */
    public void setIndexParserId(final String indexParserId) {
        //log.debug("Entering setIndexParserId(indexParserId = {})", indexParserId);
        this.indexParserId = indexParserId;
        //log.debug("Exiting setIndexParserId()");
    }

    /**
     * @return The list of {@code ManifestDrive} objects that comprise the
     *         manifest for this {@code Accession}.
     */
    public List<ManifestDrive> getManifest() {
        //log.debug("Entering getManifest()");
        //log.debug("Exiting getManifest(): {}", manifest);
        return new ArrayList<ManifestDrive>(manifest);
    }

    /**
     * Set the list of {@link ManifestDrive} that comprise the manifest for 
     * this {@code Accession}.
     * 
     * @param manifest The list of {@link ManifestDrive}s.
     */
    public void setManifest(final List<ManifestDrive> manifest) {
        //log.debug("Entering setManifest(manifest = {})", manifest);
        this.manifest = new ArrayList<ManifestDrive>(manifest);
        //log.debug("Exiting setManifest()");
    }
    
    @Override
    public void addEvent(final Event event) {
        //log.debug("Entering addEvent(event={})", event);
        this.events.add(event);
        //log.debug("Exiting addEvent()");
    }
    
    @Override
    public Set<Event> getEvents() {
        //log.debug("Entering getEvent()");
        //log.debug("Exiting getEvent(): {}", events);
        return events;
    }
    
    /**
     * @return The path in the local filesystem to the {@code Accession}'s
     *         directory, which contains its data.
     */
    public String getAccessionPath() {
        //log.debug("Entering getAccessionPath()");
        //log.debug("Exiting getAccessionPath(): {}", accessionPath);
        return accessionPath;
    }
    
    

    /**
     * Set the path in the local filesystem to the {@code Accession}'s 
     * directory, which contains its data.
     * 
     * @param accessionPath The path to the accession directory.
     */
    public void setAccessionPath(final String accessionPath) {
        //log.debug("Entering setAccessionPath(accessionPath = {})",
        //        accessionPath);
        this.accessionPath = accessionPath;
        //log.debug("Exiting setAccessionPath()");
    }

    /**
     * Gets the collection of MachineInfos that are associated with this 
     * Accession.
     * 
     * @return The collection of MachineInfo that are associated with this
     *         Accession.
     */
    public Map<String, String> getMachineInfo() {
        //log.debug("Entering getMachineInfo()");
        //log.debug("Exiting getMachineInfo(): {}", this.machineInfo);
        return new HashMap<String, String>(this.machineInfo);
    }

    /**
     * Sets the collection of MachineInfos associated with this Accession.
     * 
     * @param machineInfo The collection of MachineInfos associated with 
     *                    this Accession.     
     */
    public void setMachineInfo(Map<String, String> machineInfo) {
        //log.debug("Entering setMachineInfo(machineInfo = {})", machineInfo);
        Assert.notNull(machineInfo, "machineInfo cannot be null");
        this.machineInfo = new HashMap<String, String>(machineInfo);
        //log.debug("Exiting setMachineInfo()");
    }
    
    /**
     * Gets the systemCreator of this Accession.
     * 
     * @return The systemCreator of this Accession.
     */
    public String getSystemCreator() {
        //log.debug("Entering getSystemCreator()");
        //log.debug("Exiting getSystemCreator(): {}", this.systemCreator);
        return this.systemCreator;
    }

    /**
     * Sets the systemCreator of this Accession.
     * 
     * @param systemCreator The systemCreator of this Accession.
     */
    public void setSystemCreator(String systemCreator) {
        //log.debug("Entering setSystemCreator(systemCreator = {})", systemCreator);
        this.systemCreator = systemCreator;
        //log.debug("Exiting setSystemCreator()");
    }
    

    /**
     * Gets the version of this Accession.
     * 
     * @return The version of this Accession.
     */
    public Integer getVersion() {
        //log.debug("Entering getVersion()");
        //log.debug("Exiting getVersion(): {}", this.version);
        return this.version;
    }

    /**
     * Sets the version of this Accession.
     * 
     * @param version The version of this Accession.
     */
    public void setVersion(Integer version) {
        //log.debug("Entering setVersion(version = {})", version);
        this.version = version;
        //log.debug("Exiting setVersion()");
    }
    
    /**
     * A new entity manager is created for every persistence related function. 
     * This pattern is called an “entitymanger-per-request” pattern. 
     * In this model, a request from the client is sent to the server 
     * (where the JPA persistence layer runs), a new EntityManager is opened, 
     * and all database operations are executed in this unit of work. Once the 
     * work has been completed (and the response for the client has been
     * prepared), the persistence context is flushed and closed, as well 
     * as the entity manager object. You would also use a single database 
     * transaction to serve the clients request. The relationship between 
     * the two is one-to-one and this model is a perfect fit for many 
     * applications.
     *  
     * http://docs.jboss.org/hibernate/entitymanager/
     *  
     * @return A new EntityManager to do database operations.
     */
    public static final EntityManager entityManager() {
        staticMethodLogger().debug("Entering entityManager()");
        EntityManager em = new Accession().entityManager;
        if (em == null) {
            String errorMessage = "Throwing IllegalStateException in "
                    + "entityManager(): 'Entity manager has not been injected "
                + "(is the Spring Aspects JAR configured as an AJC/AJDT aspects library?'";
            
            staticMethodLogger().error(errorMessage);    
            throw new IllegalStateException(errorMessage);
        }
        staticMethodLogger().debug("Exiting entityManager(): {}", em);
        return em;
    }
    
    /**
     * Used to log static methods of this class. Since Autowired logger cannot 
     * be "static", this method allows an Autowired Logger to be used within 
     * static methods.
     * 
     * @return A new logger to do logging operations.
     */
    private static final Logger staticMethodLogger() {
        Logger log = new Accession().log;
        if (log == null) {
            throw new IllegalStateException("AutowiredLogger has not been"
                    + " injected!");
        }
        return log;
    }

    /**
     * Gets the amount of Accession objects that are currently in the database.
     * 
     * @return The amount of Accession objects that are currently in the
     *         database.
     */
    public static long countAccessions() {
        staticMethodLogger().debug("Entering countAccessions()");
        long count = entityManager().createQuery("SELECT COUNT(o) FROM Accession o",
                Long.class).getSingleResult();
        staticMethodLogger().debug("Exiting countAccessions(): {}", count);
        return count;
    }

    /**
     * Gets all of the Accession objects from the database and puts them in a
     * collection.
     * 
     * @return The collection of Accessions that are in the database.
     */
    public static List<Accession> findAllAccessions() {
        staticMethodLogger().debug("Entering findAllAccessions()");
        List<Accession> accessions = entityManager().createQuery("SELECT o FROM Accession o",
                Accession.class).getResultList();
        staticMethodLogger().debug("Exiting findAllAccessions(): {}", accessions);
        return accessions;
    }

    /**
     * Gets a Accession from the database according to its primaryId.
     * 
     * @param  primaryId The primary key of an Accession.
     * @return The Accession associated with the primaryId that was passed in 
     *         or null if not found.
     */
    public static Accession findAccession(String primaryId) {
        staticMethodLogger().debug("Entering findAccession(primaryId = {})", primaryId);
        if (primaryId == null || primaryId.length() <= 0) {
            staticMethodLogger().debug("Exiting findAccession(): null)");
            return null;
        }
        Accession accession = entityManager().find(Accession.class, primaryId);
        staticMethodLogger().debug("Exiting findAccession(): {})", accession);
        return accession;
    }

    /**
     * Gets a certain subset of Accessions based on the range desired.
     * 
     * @param firstResult The beginning of the range of values.
     * @param maxResults The last element of the range of values.
     * @return The collection of Accessions based on the range desired.
     */
    public static List<Accession> findAccessionEntries(int firstResult,
            int maxResults) {
        
        staticMethodLogger().debug("Entering findAccessionEntries(firstResult = {}, " +
                "maxResults = {})",
                firstResult, maxResults);
        
        List<Accession> accessions = entityManager()
                .createQuery("SELECT o FROM Accession o", Accession.class)
                .setFirstResult(firstResult).setMaxResults(maxResults)
                .getResultList();
        
        staticMethodLogger().debug("Exiting findAccessionEntries(): {}", accessions);
        return accessions;
    }

    /**
     * Persists this object to the persistence context.
     */
    @Transactional
    public void persist() {
        //log.debug("Entering persist()");
        if (this.entityManager == null) {
            this.entityManager = entityManager();
        }
        this.entityManager.persist(this);
        //log.debug("Exiting persist()");
    }

    /**
     * Removes this object from the persistence context.
     */
    @Transactional
    public void remove() {
        //log.debug("Entering remove()");
        if (this.entityManager == null)
            this.entityManager = entityManager();
        if (this.entityManager.contains(this)) {
            this.entityManager.remove(this);
        } else {
            Accession attached = Accession.findAccession(this.primaryId);
            this.entityManager.remove(attached);
        }
        //log.debug("Exiting remove()");
    }

    /**
     * Synchronize the persistence context to the underlying database.
     */
    @Transactional
    public void flush() {
        //log.debug("Entering flush()");
        if (this.entityManager == null)
            this.entityManager = entityManager();
        this.entityManager.flush();
        //log.debug("Exiting flush()");
    }

    /**
     * If you call clear, all currently managed objects of the EntityManager
     * will be detached and the status is not synchronized with the database. 
     * As long as the objects are not explicitly attached again, they are 
     * standard Java objects, whose change does not have any effect on the 
     * database.
     */
    @Transactional
    public void clear() {
        //log.debug("Entering clear()");
        if (this.entityManager == null)
            this.entityManager = entityManager();
        this.entityManager.clear();
        //log.debug("Exiting clear()");
    }

    /**
     * If this object is detached, the merge() method will merge them back into
     * the EntityManager to become managed again. Note that changes to detached
     * entity objects are not stored in the database.
     * 
     * @return The merged Accession.
     */
    @Transactional
    public Accession merge() {
        //log.debug("Entering merge()");
        if (this.entityManager == null)
            this.entityManager = entityManager();
        Accession merged = this.entityManager.merge(this);
        this.entityManager.flush();
        //log.debug("Exiting merge(): {}", merged);
        return merged;
    }

    /**
     * Assists in implementing Object.toString() methods using reflection. This
     * class uses reflection to determine the fields to append. Because these
     * fields are usually private, the class changes the visibility of the
     * fields. This will fail under a security manager, unless the appropriate
     * permissions are set up correctly.
     */
    @Override
    public String toString() {
        //log.debug("Entering toString()");
        String toString = ReflectionToStringBuilder.toString(this,
                ToStringStyle.SHORT_PREFIX_STYLE);
        //log.debug("Exiting toString(): {}", toString);
        return toString;
    }
    
    /**
	 * @return Whether the bag associated with this Accession is valid or not.
	 */
	public Boolean isBagValid() {
		return bagValid;
	}

	/**
	 * @param bagValid Set whether the bag associated with this Accession
	 *                   is valid or not.
	 */
	public void setBagValid(Boolean bagValid) {
		this.bagValid = bagValid;
	}
	
	/**
     * @return true if the accession is virus clean or false if it is not virus
     *           clean or null if it has not been scanned yet.
     */
    public Boolean isVirusClean() {
        return virusClean;
    }

    /**
     * @param virusCleaned Set true if the accession is virus clean or false if
     *          it is not virus clean or null if it has not been scanned yet.
     */
    public void setVirusCleaned(Boolean virusCleaned) {
        this.virusClean = virusCleaned;
    }
    
    /** @return Whether the RTP document of this accession is valid or not. Null
     *         if not checked. */
    public Boolean isRtpValid() {
        return rtpValid;
    }
    
    /** @param rtpValid Set true of the RTP has been validated or false if it is
     *            RTP invalid or null if it has not been validated. */
    public void setRtpValid(Boolean rtpValid) {
        this.rtpValid = rtpValid;
    }
    
    /** @param recordsExtracted True to mark Accession as having been properly
     *            records extracted, false if there was an issue. Default value
     *            is false. */
    public void setRecordsExtracted(boolean recordsExtracted) {
        this.recordsExtracted = recordsExtracted;
    }
    
    /** @return True if Accession has been properly extracted, false if there was
     *         an issue or if Accession has not yet been processed. */
    public boolean isRecordsExtracted() {
        return this.recordsExtracted;
    }
    
    /** @return The number of records associated with this Accession. */
    public int getRecordCount() {
        return this.recordCount;
    }
    
    /** @param recordCount The number of records associated with this Accession. */
    public void setRecordCount(int recordCount) {
        this.recordCount = recordCount;
    }
    
    /**
     * Sets the logger for this class.
     * 
     * @param log The logger for this class.
     */
    @AutowiredLogger
    public void setLog(Logger log) {
        this.log = log;
    }
}
