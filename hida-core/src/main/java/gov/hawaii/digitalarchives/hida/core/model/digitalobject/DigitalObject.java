package gov.hawaii.digitalarchives.hida.core.model.digitalobject;

import gov.hawaii.digitalarchives.hida.core.model.Event;
import gov.hawaii.digitalarchives.hida.core.model.Eventful;
import gov.hawaii.digitalarchives.hida.core.model.record.Representation;

import java.io.Serializable;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.Id;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.OneToMany;
import javax.persistence.PersistenceContext;
import javax.persistence.Transient;
import javax.persistence.Version;
import javax.validation.constraints.NotNull;

import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.slf4j.Logger;
import org.springbyexample.util.log.AutowiredLogger;
import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.transaction.annotation.Transactional;

/**
 * This is a common base abstract class for all other PREMIS-based
 * "Digital Object" models. All other objects, such as those meant to represent
 * files or record representations, should derive from this class.
 * 
 * @author Dongie Agnir
 * @author Keone Hiraide
 */
@Entity
// Declares the class as an entity to be persisted into a database.
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
@Configurable
// As a result, any time you instantiate an object,
// Spring will attempt to perform dependency
// injection on that object. This occurs for instantiation
// via the "new" keyword, as well as via reflection. In effect
// this feature allows dependency injection of any object at all in your
// system, which is a very useful feature (without @Configurable you'd
// only be able to dependency inject objects acquired from Spring or
// subsequently presented to a specific Spring dependency injection
// method).
public abstract class DigitalObject implements Serializable , Eventful
{

    /**
     * Autogenerated for this entity to be serializable. Implementing
     * Serializable isn't strictly necessary as far as the JPA specification
     * is concerned. However, it is needed if you're going to use caching or
     * EJB remoting, both of which require objects to be Serializable.
     * Caching is a key component in achieving optimal performance in any
     * JPA application, so implementing the Serializable interface is a good
     * habit to adopt. Note: This was taken from the book titled,
     * "Spring Persistence with Hibernate", 2010, Fisher and Murphy.
     */
    private static final long  serialVersionUID     = 838442720320617382L;

    /**
     * An {@link EntityManager} instance is associated with a persistence
     * context. A persistence context is a set of entity instances in which
     * for any persistent entity identity there is a unique entity instance.
     * Within the persistence context,the entity instances and their life cycle
     * are managed. The EntityManager API is used to create and remove
     * persistent entity instances, to find entities by their primary key,
     * and to query over entities. As long as an object is attached to an
     * EntityManager, all changes to the object will be synchronized with
     * the database automatically (Meaning that this object is attached to the
     * 'persistence context').
     */
    @PersistenceContext
    transient EntityManager    entityManager;

    /**
     * AutowiredLogger used for logging purposes.
     */
    protected transient Logger log                  = null;

    /**
     * The primary key of a DigitalObject.
     */
    @Id
    @NotNull
    @Column(name = "DIGITAL_OBJECT_ID", unique = true)
    private String             primaryId;

    /**
     * Specifies the version field or property of an entity class that serves
     * as its optimistic lock value. The version is used to ensure
     * integrity when performing the merge operation and for optimistic
     * concurrency control.
     */
    @Version
    @Column(name = "VERSION")
    private Integer            version;

    /**
     * The DigitalObject's characterized status.
     */
    @Transient
    private Boolean            characterized        = null;

    /**
     * The DigitalObject's formatValid status.
     */
    @Transient
    private Boolean            formatValid          = null;

    /**
     * Each stage generates events containing information of what happened to
     * the content of this object.
     */
    @OneToMany(cascade = CascadeType.ALL)
    private Set<Event>         events               = new TreeSet<>();

    @Transient
    private Boolean            isNative             = null;

    @Transient
    private Boolean            derivativesProcessed = null;

    /**
     * A new entity manager is created for every persistence related function.
     * This pattern is called an “entitymanger-per-request” pattern.
     * In this model, a request from the client is sent to the server
     * (where the JPA persistence layer runs), a new EntityManager is opened,
     * and all database operations are executed in this unit of work. Once the
     * work has been completed (and the response for the client has been
     * prepared), the persistence context is flushed and closed, as well
     * as the entity manager object. You would also use a single database
     * transaction to serve the clients request. The relationship between
     * the two is one-to-one and this model is a perfect fit for many
     * applications.
     * 
     * http://docs.jboss.org/hibernate/entitymanager/
     * 
     * @return A new EntityManager to do database operations.
     */
    public static final EntityManager entityManager ()
    {
        staticMethodLogger().debug("Entering entityManager()");
        EntityManager em = new DigitalObject()
        {
            public void addEvent (final Event event)
            {
                throw new UnsupportedOperationException();
            }

            public Set<Event> getEvents ()
            {
                throw new UnsupportedOperationException();
            }

            public String getRepresentationId ()
            {
                throw new UnsupportedOperationException();
            }

            public String getSourceObjectId ()
            {
                throw new UnsupportedOperationException();
            }

            public void setRepresentationId (String representationId)
            {
                throw new UnsupportedOperationException();
            }

            public void setSourceObjectId (String sourceObjectId)
            {
                throw new UnsupportedOperationException();
            }
        }.entityManager;
        if (em == null)
        {
            String errorMessage = "Throwing IllegalStateException in "
                    + "entityManager(): 'Entity manager has not been injected "
                    + "(is the Spring Aspects JAR configured as an AJC/AJDT aspects library?'";
            staticMethodLogger().error(errorMessage);

            throw new IllegalStateException(errorMessage);
        }
        staticMethodLogger().debug("Exiting entityManager(): {}", em);
        return em;
    }

    /**
     * Used to log static methods of this class. Since
     * Autowired logger cannot be "static", this method allows an
     * Autowired Logger to be used within static methods.
     * 
     * @return A new logger to do logging operations.
     */
    protected static final Logger staticMethodLogger ()
    {
        Logger log = new DigitalObject()
        {
            public void addEvent (final Event event)
            {
                throw new UnsupportedOperationException();
            }

            public Set<Event> getEvents ()
            {
                throw new UnsupportedOperationException();
            }

            public String getRepresentationId ()
            {
                throw new UnsupportedOperationException();
            }

            public String getSourceObjectId ()
            {
                throw new UnsupportedOperationException();
            }

            public void setRepresentationId (String representationId)
            {
                throw new UnsupportedOperationException();
            }

            public void setSourceObjectId (String sourceObjectId)
            {
                throw new UnsupportedOperationException();
            }
        }.log;
        if (log == null)
        {
            throw new IllegalStateException("AutowiredLogger has not been" + " injected!");
        }
        return log;
    }

    /**
     * Gets the amount of DigitalObject objects that are currently in the
     * database.
     * 
     * @return The amount of DigitalObject objects that are currently in the
     *         database.
     */
    public static long countDigitalObjects ()
    {
        staticMethodLogger().debug("Entering countDigitalObjects()");
        long count = entityManager()
                .createQuery("SELECT COUNT(o) FROM DigitalObject o", Long.class).getSingleResult();
        staticMethodLogger().debug("Exiting countDigitalObjects(): {}", count);
        return count;
    }

    /**
     * Gets all of the DigitalObject objects from the database and puts them in
     * a collection.
     * 
     * @return The collection of DigitalObjects that are in the database.
     */
    public static List<DigitalObject> findAllDigitalObjects ()
    {
        staticMethodLogger().debug("Entering findAllDigitalObjects()");
        List<DigitalObject> digitalObjects = entityManager().createQuery(
                "SELECT o FROM DigitalObject o", DigitalObject.class).getResultList();

        staticMethodLogger().debug("Exiting findAllDigitalObjects(): {}", digitalObjects);
        return digitalObjects;
    }

    /**
     * Gets a DigitalObject from the database according to its primaryId.
     * 
     * @param primaryId The primary key of a MachineInfoPair.
     * @return The DigitalObject associated with the primaryId that was passed
     *         in or null if not found.
     */
    public static DigitalObject findDigitalObject (String primaryId)
    {
        staticMethodLogger().debug("Entering findDigitalObject(primaryId = {})", primaryId);
        if (primaryId == null || primaryId.length() <= 0)
        {
            staticMethodLogger().debug("Exiting findDigitalObject(): null");
            return null;
        }
        DigitalObject digitalObject = entityManager().find(DigitalObject.class, primaryId);
        staticMethodLogger().debug("Exiting findDigitalObject(): {})", digitalObject);
        return digitalObject;
    }

    /**
     * Gets a certain subset of DigitalObjects based on the range desired.
     * 
     * @param firstResult The beginning of the range of values.
     * @param maxResults The last element of the range of values.
     * @return The collection of DigitalObjects based on the range desired.
     */
    public static List<DigitalObject> findDigitalObjectEntries (int firstResult, int maxResults)
    {
        staticMethodLogger().debug(
                "Entering findDigitalObjectEntries(firstResult = {}, maxResults = {})",
                firstResult, maxResults);

        List<DigitalObject> digitalObjects = entityManager()
                .createQuery("SELECT o FROM DigitalObject o", DigitalObject.class)
                .setFirstResult(firstResult).setMaxResults(maxResults).getResultList();

        staticMethodLogger().debug("Exiting findDigitalObjectEntries(): {}", digitalObjects);
        return digitalObjects;
    }

    @Override
    public void addEvent (final Event event)
    {
        log.debug("Entering addEvent(event={})", event);
        this.events.add(event);
        log.debug("Exiting addEvent()");
    }

    /**
     * If you call clear, all currently managed objects of the EntityManager
     * will be detached and the status is not synchronized with the database.
     * As long as the objects are not explicitly attached again, they are
     * standard Java objects, whose change does not have any effect on
     * the database.
     */
    @Transactional
    public void clear ()
    {
        log.debug("Entering clear()");
        if (this.entityManager == null) this.entityManager = entityManager();
        this.entityManager.clear();
        log.debug("Exiting clear()");
    }

    /**
     * Synchronize the persistence context to the underlying database.
     */
    @Transactional
    public void flush ()
    {
        log.debug("Entering flush()");
        if (this.entityManager == null) this.entityManager = entityManager();
        this.entityManager.flush();
        log.debug("Exiting flush()");
    }

    @Override
    public Set<Event> getEvents ()
    {
        log.debug("Entering getEvent()");
        log.debug("Exiting getEvent(): {}", events);
        return events;
    }

    /**
     * @return The ID of this object.
     */
    public String getPrimaryId ()
    {
        log.debug("Entering getPrimaryId()");
        log.debug("Exiting getPrimaryId(): {}", primaryId);
        return primaryId;
    }

    /**
     * @return The ID of the {@link Representation} this object belongs to.
     */
    public abstract String getRepresentationId ();

    /**
     * @return The ID of the record this object belongs to.
     */
    public abstract String getSourceObjectId ();

    /**
     * Gets the version of this DigitalObject.
     * 
     * @return The version of this DigitalObject.
     */
    public Integer getVersion ()
    {
        log.debug("Entering getVersion()");
        log.debug("Exiting getVersion(): {}", this.version);
        return this.version;
    }

    /**
     * If this object is detached, the merge() method will merge them back into
     * the EntityManager to become managed again. Note that changes to detached
     * entity objects are not stored in the database.
     * 
     * @return The merged DigitalObject.
     */
    @Transactional
    public DigitalObject merge ()
    {
        log.debug("Entering merge()");
        if (this.entityManager == null) this.entityManager = entityManager();
        DigitalObject merged = this.entityManager.merge(this);
        this.entityManager.flush();
        log.debug("Exiting merge(): {}", merged);
        return merged;
    }

    /**
     * Persists this object to the persistence context.
     */
    @Transactional
    public void persist ()
    {
        log.debug("Entering persist()");
        if (this.entityManager == null) this.entityManager = entityManager();
        this.entityManager.persist(this);
        log.debug("Exiting persist()");
    }

    /**
     * Removes this object from the persistence context.
     */
    @Transactional
    public void remove ()
    {
        log.debug("Entering remove()");
        if (this.entityManager == null) this.entityManager = entityManager();
        if (this.entityManager.contains(this))
        {
            this.entityManager.remove(this);
        }
        else
        {
            DigitalObject attached = DigitalObject.findDigitalObject(this.primaryId);
            this.entityManager.remove(attached);
        }
        log.debug("Exiting remove()");
    }

    /**
     * Set the ID of this object.
     * 
     * @param primaryId The primaryId of this object.
     */
    public void setPrimaryId (final String primaryId)
    {
        log.debug("Entering setPrimaryId(primaryId = {})", primaryId);
        this.primaryId = primaryId;
        log.debug("Exiting setPrimaryId()");
    }

    /**
     * @return True if object has been marked as native, false if not native,
     *         and null if unprocessed.
     */
    public Boolean isNative ()
    {
        return this.isNative;
    }

    /**
     * @param isNative True to mark object as native, false for not native, or
     *            null for unprocessed.
     */
    public void setIsNative (Boolean isNative)
    {
        this.isNative = isNative;
    }

    /**
     * @return True if object has been marked as derivatives processed, false if
     *         not, and null if object has not been processed.
     */
    public Boolean isDerivativesProcessed ()
    {
        return this.derivativesProcessed;
    }

    /**
     * @param derivativesProcessed True to mark object as derivatives processed,
     *            false for not derivatives processed, and null for unprocessed.
     */
    public void setDerivativesProcessed (Boolean derivativesProcessed)
    {
        this.derivativesProcessed = derivativesProcessed;
    }
    
    /** @return True if format has been determined valid, false if invalid, and
     *         null if unchecked or format wasn't known. */
    public Boolean isFormatValid() {
        return this.formatValid;
    }
    
    /** @param formatValid True to mark format as valid, false for invalid, or
     *            null to indicate that format has not been checked. */
    public void setFormatValid(Boolean formatValid) {
        this.formatValid = formatValid;
    }

    /**
     * Set the ID of the {@link Representation} that this object belongs to.
     * 
     * @param representationId The ID of the Representation that this object
     *            belongs to.
     */
    public abstract void setRepresentationId (String representationId);

    /**
     * Set the ID of the DigitalObject this one was created from.
     * 
     * @param sourceObjectId The ID of the DigitalObject that this was
     *            created from.
     */
    public abstract void setSourceObjectId (String sourceObjectId);

    /**
     * Sets the version of this DigitalObject.
     * 
     * @param version The version of this DigitalObject.
     */
    public void setVersion (Integer version)
    {
        log.debug("Entering setVersion(version = {})", version);
        this.version = version;
        log.debug("Exiting setVersion()");
    }

    /**
     * Assists in implementing Object.toString() methods using reflection.
     * This class uses reflection to determine the fields to append. Because
     * these fields are usually private, the class changes the visibility of
     * the fields. This will fail under a security manager,
     * unless the appropriate permissions are set up correctly.
     */
    @Override
    public String toString ()
    {
        log.debug("Entering toString()");
        String toString = ReflectionToStringBuilder
                .toString(this, ToStringStyle.SHORT_PREFIX_STYLE);
        log.debug("Exiting toString(): {}", toString);
        return toString;
    }

    /**
     * Sets the logger for this class.
     * 
     * @param log The logger for this class.
     */
    @AutowiredLogger
    public void setLog (Logger log)
    {
        this.log = log;
    }

    /**
     * @return True if the digital object has been characterized, false if it
     *         failed to be characterized, or null if it has not been
     *         characterized.
     */
    public Boolean isCharacterized ()
    {
        return this.characterized;
    }

    /**
     * @param characterized Set true if characterized or false if it has not
     *            been characterized.
     */
    public void setCharacterized (boolean characterized)
    {
        this.characterized = characterized;
    }
}
