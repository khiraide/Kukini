package gov.hawaii.digitalarchives.hida.core.model;

import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.Id;
import javax.persistence.PersistenceContext;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.validation.constraints.NotNull;

import org.slf4j.Logger;
import org.springbyexample.util.log.AutowiredLogger;
import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;


/**
 * The Event model class.  Guarantees the immutability of the Event.
 * <p>
 * @author Dongie Agnir
 * @author Keone Hiraide
 */
@Configurable
@Entity
@Table(name="EVENT")
public class Event implements Serializable ,Comparable<Event>{
	
    /**
     * Autogenerated for this entity to be serializable. Implementing
     * Serializable isn't strictly necessary as far as the JPA specification
     * is concerned. However, it is needed if you're going to use caching or
     * EJB remoting, both of which require objects to be Serializable.
     * Caching is a key component in achieving optimal performance in any
     * JPA application, so implementing the Serializable interface is a good
     * habit to adopt. Note: This was taken from the book titled, 
     * "Spring Persistence with Hibernate", 2010, Fisher and Murphy. 
     */
    private static final long serialVersionUID = 3405732893916936443L;

	/**
	 * An {@link EntityManager} instance is associated with a persistence 
	 * context. A persistence context is a set of entity instances in which 
	 * for any persistent entity identity there is a unique entity instance. 
	 * Within the persistence context, the entity instances and their life cycle 
	 * are  managed. The EntityManager API is used to create and remove 
	 * persistent entity instances, to find  entities by their primary key, 
	 * and to query over entities. As long as an object is attached to an 
	 * EntityManager, all changes to the object will be synchronized with 
	 * the database automatically (Meaning that this object is attached to the
	 * 'persistence context'). 
	 */
	@PersistenceContext
    transient EntityManager entityManager;
	
	//The date of this event.
	@Column(name="EVENT_DATE")
	private Date eventDate;
	
	//The detail message for this event.
	@Column(name="EVENT_DETAIL")
	private String eventDetail;

	/**
	 * Primary Id of the Event.
	 */
	@Id
    @NotNull
    @Column(name="EVENT_ID", unique = true)
	private String primaryId;


	/**
	 * Enum value that denote a specific type of event.
	 */
	@Enumerated(EnumType.STRING)
	@Column(name="EVENT_TYPE")
	private EventType type;

	/**
	 * Specifies the version field or property of an entity class that serves 
	 * as its optimistic lock value. The version is used to ensure 
	 * integrity when performing the merge operation and for optimistic 
	 * concurrency control. 
	 */
	@Version
    @Column(name = "VERSION")
    private Integer version;
	
	/**
	 * Collection of enum values that denote a specific type of event.
	 * 
	 * All entries are taken from Adam's Document "PREMIS EVENTS -- Hawaii 
	 * Digital Archives".
	 *
	 */
	public enum EventType {
			
		CAPTURE("capture"),
		CHARACTERIZATION("characterization"),
		COMPRESSION("compression"),
		CREATION("creation"),
		DEACCESSION("deaccession"),
		DECOMPRESSION("decompression"),
		DECRYPTION("decryption"),
		DELETION("deletion"),
		DIGITAL_SIGNATURE_VALIDATION("digital signature validation"),
		DISSEMINATION("dissemination"),
		FIXITY_CHECK("fixity check"),
		INGESTION("ingestion"),
		MESSAGE_DIGEST_CALCULATION("message digest calculation"),
		MIGRATION("migration"),
		NORMALIZATION("normalization"),
		REPLICATION("replication"),
		VALIDATION("validation"),
		VIRUS_CHECK("virus check");
			
		private String text;
			
		EventType(final String text) {
			this.text = text;
		}
		/**
		 * @return The textual representation of this event type (it's name).
		 */
		public String getText() {
			return text;
		}
	}
	
	/**
     * AutowiredLogger for logging purposes.
     */
    private transient Logger log = null;
	
	
	/**
     * Oracle specifications state that the class must have a public 
     * or protected, no-argument constructor. The class may have other 
     * constructors. 
     * http://docs.oracle.com/javaee/7/tutorial/doc/persistence-intro001.htm
     */
	public Event() {
		
	}

	
	
	/**
	 * Constructor used to create a Event with its proper values.
	 * 
	 * @param primaryId  Primary Id of the Event.
	 * @param type  The type of Event.
	 * @param eventDate  The date of when the event happened.
	 * @param eventDetail  The details of the event.
	 */
	public Event(final String primaryId, final EventType type, final Date eventDate,
			final String eventDetail) {
        Assert.notNull(primaryId, "primaryId cannot be null.");
        Assert.notNull(type, "eventType cannot be null.");
        Assert.notNull(eventDate, "eventDate cannot be null.");
        Assert.notNull(eventDetail, "eventDetail cannot be null.");

		this.primaryId = primaryId;
		this.type = type;
		this.eventDate = new Date(eventDate.getTime());
		this.eventDetail = eventDetail;
	}
	
	
	/**
     * A new entity manager is created for every persistence related function. 
     * This pattern is called an “entitymanger-per-request” pattern. 
     * In this model, a request from the client is sent to the server 
     * (where the JPA persistence layer runs), a new EntityManager is opened, 
     * and all database operations are executed in this unit of work. Once the 
     * work has been completed (and the response for the client has been
     * prepared), the persistence context is flushed and closed, as well 
     * as the entity manager object. You would also use a single database 
     * transaction to serve the clients request. The relationship between 
     * the two is one-to-one and this model is a perfect fit for many 
     * applications.
     *  
     * http://docs.jboss.org/hibernate/entitymanager/
     *  
     * @return A new EntityManager to do database operations.
     */
    public static final EntityManager entityManager() {
        staticMethodLogger().debug("Entering entityManager()");
        EntityManager em = new Event().entityManager;
        if (em == null) {
            staticMethodLogger().error("Throwing IllegalStateException in "
                    + "entityManager(): 'Entity manager has not been injected "
                + "(is the Spring Aspects JAR configured as an AJC/AJDT aspects library?'");
            
            throw new IllegalStateException(
                    "Entity manager has not been injected"
                            + " (is the Spring Aspects JAR configured as an " +
                            "AJC/AJDT aspects library?)");
        }
        staticMethodLogger().debug("Exiting entityManager(): {}", em);
        return em;
    }

    
    
    /**
     * Used to log static methods of this class. Since
     * Autowired logger cannot be "static", this method allows an 
     * Autowired Logger to be used within static methods.
     * 
     * @return A new logger to do logging operations.
     */
    private static final Logger staticMethodLogger() {
        Logger log = new Event().log;
        if (log == null) {
            throw new IllegalStateException("AutowiredLogger has not been"
                    + " injected!");
        }
        return log;
    }
    
    
    
	/**
	 * Gets the amount of Event objects that are currently 
	 * in the database.
	 * 
	 * @return The amount of Event objects that are 
	 *         currently in the database.
	 */
	public static long countEvents() {
	    staticMethodLogger().debug("Entering countEvents()");
        long count = entityManager().createQuery("SELECT COUNT(o) FROM Event o",
                Long.class).getSingleResult();
        staticMethodLogger().debug("Exiting countEvents(): {}", count);
        return count;
    }
	
	
	
	/**
	 * Gets all the Event objects from the database 
	 * and puts them in a collection. 
	 * 
	 * @return The collection of Events that are 
	 *         in the database.
	 */
	public static List<Event> findAllEvents() {
	    staticMethodLogger().debug("Entering findAllEvents()");
        List<Event> events = entityManager()
                .createQuery("SELECT o FROM Event o", Event.class)
                .getResultList();
        staticMethodLogger().debug("Exiting findAllEvents(): {}", events);
        return events;
    }
	
	
	/**
	 * Queries for an Event from the database based on its primaryId.
	 * 
	 * @param primaryId  The String primaryId associated with the 
	 *                   Event that you want to search the database for.
	 * @return           The associated Event matching the primaryId you were
	 *                   searching for, or null if not found.
	 */
	public static Event findEvent(String primaryId) {
	    staticMethodLogger().debug("Entering findEvent(primaryId = {})", primaryId);
        if (primaryId == null) {
            staticMethodLogger().debug("Exiting findEvent(): null)");
            return null;
        }
        Event event = entityManager()
                .find(Event.class, primaryId);
        staticMethodLogger().debug("Exiting findEvent(): {})", event);
        return event;
    }
	
	/**
	 * Gets a certain subset of Events based 
	 * on the range desired.
	 * 
	 * @param firstResult  The beginning of the range of values.
	 * @param maxResults   The last element of the range of values.
	 * @return             The collection of Events based 
	 *                     on the range desired. 
	 */
	public static List<Event> findEventEntries(int firstResult, int maxResults) {
	    staticMethodLogger().debug("Entering findEventEntries(firstResult = {}, " +
                "maxResults = {})", firstResult, maxResults);
        
        List<Event> entries = entityManager()
                .createQuery("SELECT o FROM Event o", Event.class)
                .setFirstResult(firstResult).setMaxResults(maxResults)
                .getResultList();
        
        staticMethodLogger().debug("Exiting findEventEntries(): {}", entries);
        return entries;
    }

	
	
	/**
	 * If you call clear, all currently managed objects of the EntityManager 
	 * will be detached and the status is not synchronized with the database. 
	 * As long as the objects are not explicitly attached again, they are 
	 * standard Java objects, whose change does not have any effect on 
	 * the database.
	 */
	@Transactional
    public void clear() {
	    log.debug("Entering clear()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        this.entityManager.clear();
        log.debug("Exiting clear()");
    }
	
	@Override
	public boolean equals(Object rhs) {
	    log.debug("Entering equals(rhs = {})", rhs);
		//can't be equal to a null ref.
		if (rhs == null) {
		    log.debug("Exiting equals(): false");
			return false;
		}
		
		//Can't be equal if it's not an event Object.
		if (!(rhs instanceof Event)) {
		    log.debug("Exiting equals(): false");
			return false;
		}
		
		//Comparison to self.  Watch out for random identity crisis.
		if (rhs == this) {
		    log.debug("Exiting equals(): true");
			return true;
		}
		
		Event rhsEvent = (Event) rhs;
		boolean result = getPrimaryId().toString() == rhsEvent.getPrimaryId().toString()
                && getType() == rhsEvent.getType()
                && getEventDate().equals(rhsEvent.getEventDate())
                && getEventDetail().equals(rhsEvent.getEventDetail());
		
		log.debug("Exiting equals(): {}", result);
		
		return result;
	}
	
	/**
	 * Synchronize the persistence context to the underlying database. 
	 */
	@Transactional
    public void flush() {
	    log.debug("Entering flush()");
        if (this.entityManager == null)
            this.entityManager = entityManager();
        this.entityManager.flush();
        log.debug("Exiting flush()");
    }
	
	/**
     * @return The date this even took place.  Guaranteed to not be
     * {@code null}.
     */
	public Date getEventDate() {
	    log.debug("Exiting getEventDate(): {}", this.eventDate);
        return new Date(this.eventDate.getTime());
    }
	
	/**
     * @return Detailed information of the event as a string.  This object 
     * does not specify a specific format.  
     */
	public String getEventDetail() {
	    log.debug("Exiting getEventDetail(): {}", this.eventDetail);
        return this.eventDetail;
    }

	
	
	/**
	 * Gets the primary id associated with this event.
	 * 
	 * @return The primary id associated with this event.
	 */
	public String getPrimaryId() {
	    log.debug("Entering getPrimaryId()");
        log.debug("Exiting getPrimaryId(): {}", primaryId);
        return primaryId;
    }

	
	
	public HashMap<String, String> getRelatedAgents() {
		// TODO Auto-generated method stub
	    log.debug("Exiting getRelatedAgents(): null");
		return null;
	}

	
	
	public HashMap<String, String> getRelatedObjects() {
		// TODO Auto-generated method stub
	    log.debug("Exiting getRelatedObjects(): null");
		return null;
	}
	
	/**
     * @return The type corresponding to this specific event.
     */
	public EventType getType() {
	    log.debug("Exiting getType(): {}", this.type);
        return this.type;
    }

	
	
	/**
	 * Gets the version of this Event.
	 * 
	 * @return The version of this Event.
	 */
	public Integer getVersion() {
	    log.debug("Exiting getVersion(): {}", this.version);
        return this.version;
    }

	
	
	//Computation based on Effective Java 2nd Ed.
	@Override
	public int hashCode() {
	    log.debug("Entering hashCode()");
		int result = 17;
		
		result = result * 31 + getPrimaryId().toString().hashCode();
		result = result * 31 + getType().hashCode();
		result = result * 31 + getEventDate().hashCode();
		result = result * 31 + getEventDetail().hashCode();
		
		log.debug("Exiting hashCode(): {}", result);
		return result;
	}

	
	
	public boolean isAParty() {
		//nope.
		 // lol
		return false;
	}

	
	
	/**
	 * If this object is detached, the merge() method will merge them back into
	 * the EntityManager to become managed again. Note that changes to detached
	 * entity objects are not stored in the database.
	 * 
	 * @return The merged Event.
	 */
	@Transactional
    public Event merge() {
	    log.debug("Entering merge()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        Event merged = this.entityManager.merge(this);
        this.entityManager.flush();
        log.debug("Exiting merge(): {}", merged);
        return merged;
    }
	
	/**
	 * Persists this object to the persistence context. 
	 */
	@Transactional
    public void persist() {
	    log.debug("Entering persist()");
        if (this.entityManager == null) {
            this.entityManager = entityManager();
        }
        this.entityManager.persist(this);
        log.debug("Exiting persist()");
    }

	
	
	/**
	 * Removes this object from the persistence context. 
	 */
	@Transactional
    public void remove() {
	    log.debug("Entering remove()");
        if (this.entityManager == null) 
            this.entityManager = entityManager();
        if (this.entityManager.contains(this)) {
            this.entityManager.remove(this);
        } else {
            Event attached = Event.findEvent(this.primaryId);
            this.entityManager.remove(attached);
        }
        log.debug("Exiting remove()");
    }

	
	/**
	 * Sets the version of this Event.
	 * 
	 * @param version The version of this Event.
	 */
	public void setVersion(Integer version) {
	    log.debug("Entering setVersion(version = {})", version);
        this.version = version;
    }

	
	
	/**
	 *  Assists in implementing Object.toString() methods using reflection.
	 *  This class uses reflection to determine the fields to append. Because 
	 *  these fields are usually private, the class changes the visibility of 
	 *  the fields. This will fail under a security manager,
	 *  unless the appropriate permissions are set up correctly. 
	 */
	@Override
	public String toString() {
	    log.debug("Entering toString()");
        // Avoiding use of ReflectionToStringBuilder here due to infinite
        // recursion issue.
	    String toString = "Event[eventDate=" + this.eventDate + 
	            ", eventDetail=" + this.eventDetail + 
	            ", primaryId=" + this.primaryId + 
	            ", type=" + this.type + 
	            ", version=" + this.version + "]";
        log.debug("Exiting toString(): {}", toString);
        return toString;
    }

    @Override
    public int compareTo (Event other)
    {
        return this.primaryId.compareTo(other.primaryId);
    }
    
    /**
     * Sets the logger for this class.
     * 
     * @param log The logger for this class.
     */
    @AutowiredLogger
    public void setLog(Logger log) {
        this.log = log;
    }
}
