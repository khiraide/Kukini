package gov.hawaii.digitalarchives.hida.core.model;

import java.io.Serializable;
import java.util.Arrays;
import java.util.List;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.PersistenceContext;
import javax.persistence.Table;
import javax.persistence.Version;

import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.slf4j.Logger;
import org.springbyexample.util.log.AutowiredLogger;
import org.springframework.beans.factory.annotation.Configurable;


/**
 * Implementation of the DigitalSignature object.
 * 
 * @author Dongie Agnir
 * @author Keone Hiraide
 */
@Entity
@Configurable
@Table(name = "DIGITAL_SIGNATURE")
public class DigitalSignature implements Serializable {
	
    /**
     * Autogenerated for this entity to be serializable. Implementing
     * Serializable isn't strictly necessary as far as the JPA specification
     * is concerned. However, it is needed if you're going to use caching or
     * EJB remoting, both of which require objects to be Serializable.
     * Caching is a key component in achieving optimal performance in any
     * JPA application, so implementing the Serializable interface is a good
     * habit to adopt. Note: This was taken from the book titled, 
     * "Spring Persistence with Hibernate", 2010, Fisher and Murphy. 
     */
    private static final long serialVersionUID = 222900890006527010L;

    /**
	 * Primary id associated with this DigitalSignature and its subclasses.
	 */
	@Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    @Column(name = "DIGITAL_SIGNATURE_ID")
    private Long primaryId;

	/**
	 * Specifies the version field or property of an entity class that serves 
	 * as its optimistic lock value. The version is used to ensure 
	 * integrity when performing the merge operation and for optimistic 
	 * concurrency control. 
	 */
	@Version
    @Column(name="VERSION")
    private Integer version;
	
	/** 
     * The algorithm used to sign this DigitalSignature.
     */
	@Column(name="ALGORITHM")
    private String algorithm;
    
    /** 
     * The public key used for this DigitalSignature.
     */
	@Column(name="PUBLIC_KEY")
    private byte[] publicKey;
    
    /** 
     * The signature bytes of this DigitalSignature.
     */
	@Column(name="SIGNATURE_BYTES")
    private byte[] signatureBytes;
    
    /** 
	 * The name of the signer for this DigitalSignature. 
	 */
	@Column(name="SIGNER")
    private String signer;
    
    /**
     * An {@link EntityManager} instance is associated with a persistence 
     * context. A persistence context is a set of entity instances in which 
     * for any persistent entity identity there is a unique entity instance. 
     * Within the persistence context, the entity instances and their life cycle 
     * are  managed. The EntityManager API is used to create and remove 
     * persistent entity instances, to find  entities by their primary key, 
     * and to query over entities. As long as an object is attached to an 
     * EntityManager, all changes to the object will be synchronized with 
     * the database automatically (Meaning that this object is attached to the
     * 'persistence context'). 
     */
    @PersistenceContext
    transient EntityManager entityManager;
    
    /**
     * AutowiredLogger for logging purposes.
     */
    private transient Logger log = null;
	
    /**
     * Oracle specifications state that the class must have a public 
     * or protected, no-argument constructor. The class may have other 
     * constructors. 
     * http://docs.oracle.com/javaee/7/tutorial/doc/persistence-intro001.htm
     */
    public DigitalSignature() {
    	
    }

    
    
    /**
     * Constructs a DigitalSignature object ensuring that the values are
     * not null.
     * 
     * @param signer  The name of the signer for this DigitalSignature. 
     * @param algorithm  The algorithm used to sign this DigitalSignature.
     * @param signatureBytes  The signature bytes of this DigitalSignature.
     * @param publicKey  The public key used for this DigitalSignature.
     */
    public DigitalSignature(final String signer, final String algorithm, 
			final byte[] signatureBytes, final byte[] publicKey) {
		if (signer == null) {
			throw new IllegalArgumentException("signer cannot be null.");
		}

		if (algorithm == null) {
			throw new IllegalArgumentException("algorithm cannot be null.");
		}
		
		if (signatureBytes == null) {
			throw new IllegalArgumentException("signatureBytes cannot be null.");
		}
		
		if (publicKey == null) {
			throw new IllegalArgumentException("publicKey cannot be null.");
		}
		
		this.signer = signer;
		this.algorithm = algorithm;
		this.signatureBytes = Arrays.copyOf(signatureBytes, signatureBytes.length);
		this.publicKey = Arrays.copyOf(publicKey, publicKey.length);
	}

	
	
	/**
     * Constructs this class with values based on the Digital Signature passed
     * in.
     * 
     * @param rhs  Creates this DigitalSignature with values from another
     *             already created, DigitalSignature.
     */
    public DigitalSignature(final DigitalSignature rhs) {
        log.debug("Entering DigitalSignature(rhs = {})", rhs);
		this.signer = rhs.getSigner();
		this.algorithm = rhs.getAlgorithm();
		this.signatureBytes = rhs.getSignatureBytes();
		this.publicKey = rhs.getPublicKey();
	}

    
    
    /**
	 * @return The primary id associated with this Digital Signature.
	 */
	public Long getPrimaryId() {
	    log.debug("Exiting getPrimaryId(): {}", this.primaryId);
        return this.primaryId;
    }
	
	
	/**
	 * Sets the version of this DigitalSignature.
	 * 
	 * @param version  The version of this DigitalSignature.
	 */
	public void setVersion(Integer version) {
	    log.debug("Exiting setVersion(version = {})", this.version);
        this.version = version;
    }
    
	
	
	/**
	 * Gets the version of this DigitalSignature.
	 * 
	 * @return The version of this DigitalSignature.
	 */
	public Integer getVersion() {
	    log.debug("Exiting getVersion(): {}", this.version);
        return this.version;
    }
    
	
	/**
     * A new entity manager is created for every persistence related function. 
     * This pattern is called an “entitymanger-per-request” pattern. 
     * In this model, a request from the client is sent to the server 
     * (where the JPA persistence layer runs), a new EntityManager is opened, 
     * and all database operations are executed in this unit of work. Once the 
     * work has been completed (and the response for the client has been
     * prepared), the persistence context is flushed and closed, as well 
     * as the entity manager object. You would also use a single database 
     * transaction to serve the clients request. The relationship between 
     * the two is one-to-one and this model is a perfect fit for many 
     * applications.
     *  
     * http://docs.jboss.org/hibernate/entitymanager/
     *  
     * @return A new EntityManager to do database operations.
     */
	public static final EntityManager entityManager() {
	    staticMethodLogger().debug("Entering entityManager()");
        EntityManager em = new DigitalSignature().entityManager;
        if (em == null) {
            staticMethodLogger().error("Throwing IllegalStateException in "
                    + "entityManager(): 'Entity manager has not been injected "
                + "(is the Spring Aspects JAR configured as an AJC/AJDT aspects library?'");
            
            throw new IllegalStateException(
                    "Entity manager has not been injected"
                            + " (is the Spring Aspects JAR configured as an " +
                            "AJC/AJDT aspects library?)");
        }
        staticMethodLogger().debug("Exiting entityManager(): {}", em);
        return em;
    }
	
	
	/**
     * Used to log static methods of this class. Since
     * Autowired logger cannot be "static", this method allows an 
     * Autowired Logger to be used within static methods.
     * 
     * @return A new logger to do logging operations.
     */
    private static final Logger staticMethodLogger() {
        Logger log = new DigitalSignature().log;
        if (log == null) {
            throw new IllegalStateException("AutowiredLogger has not been"
                    + " injected!");
        }
        return log;
    }
    
    
    
	/**
     * Gets the amount of DigitalSiganture instances that are in the 
     * database.
     * 
     * @return The count of DigitalSignatures that are currently in the
     * 		   database.
     */
	public static long countDigitalSignatures() {
	    staticMethodLogger().debug("Entering countDigitalSignatures()");
        long count = entityManager().createQuery("SELECT COUNT(o) FROM DigitalSignature o",
                Long.class).getSingleResult();
        staticMethodLogger().debug("Exiting countDigitalSignatures(): {}", count);
        return count;
    }

    /**
	 * Gets a List of all the DigitalSignatures that are currently 
	 * in the database.
	 * 
	 * @return A List holding all of the DigitalSignatures that are
	 * 	 	   currently in the database.
	 */
	public static List<DigitalSignature> findAllDigitalSignatures() {
	    staticMethodLogger().debug("Entering findAllDigitalSignatures()");
        List<DigitalSignature> digitalSignatures = entityManager()
                .createQuery("SELECT o FROM DigitalSignature o", DigitalSignature.class)
                .getResultList();
        staticMethodLogger().debug("Exiting findAllDigitalSignatures(): {}", digitalSignatures);
        return digitalSignatures;
    }

    /**
	 * Gets a DigitalSignature from the database according to its primary Id.
	 * 
	 * @param primaryId   The primary key of a DigitalSignature.
	 * @return     The DigitalSignature associated with the id that was
	 * 		       passed in or null if not found.
	 */
	public static DigitalSignature findDigitalSignature(Long primaryId) {
	    staticMethodLogger().debug("Entering findDigitalSignature(primaryId = {})", primaryId);
        if (primaryId == null) {
            staticMethodLogger().debug("Exiting findDigitalSignature(): null)");
            return null;
        }
        DigitalSignature digitalSignature = entityManager()
                .find(DigitalSignature.class, primaryId);
        staticMethodLogger().debug("Exiting findDigitalSignature(): {})", digitalSignature);
        return digitalSignature;
    }

    /**
	 * Gets a List filled with a range of DigitalSignatures.
	 * 
	 * @param firstResult   First value in the range.
	 * @param maxResults    Max value in the range.
	 * @return              A List filled with a range of 
	 *                      DigitalSignatures.
	 */
	public static List<DigitalSignature> 
	findDigitalSignatureEntries(int firstResult, int maxResults) {
	    staticMethodLogger().debug("Entering findDigitalSignatureEntries(firstResult = {}, " +
                "maxResults = {})", firstResult, maxResults);
        
        List<DigitalSignature> digitalSignatures = entityManager()
                .createQuery("SELECT o FROM DigitalSignature o", DigitalSignature.class)
                .setFirstResult(firstResult).setMaxResults(maxResults)
                .getResultList();
        
        staticMethodLogger().debug("Exiting findDigitalSignatureEntries(): {}", digitalSignatures);
        return digitalSignatures;
    }
    
	
	
	
	/**
	 * Gets the algorithm associated with this DigitalSignature.
	 * 
	 * @return The algorithm associated with this DigitalSignature.
	 */
	public String getAlgorithm() {
	    log.debug("Exiting getAlgorithm(): {}", this.algorithm);
        return this.algorithm;
    }

	
	
	/**
	 * Gets the public key associated with this DigitalSignature.
	 * 
	 * @return The public key associated with this DigitalSignature.
	 */
	public byte[] getPublicKey() {
	    log.debug("Exiting getPublicKey(): {}", 
	            Arrays.copyOf(this.publicKey, this.publicKey.length));
		return Arrays.copyOf(this.publicKey, this.publicKey.length);
    }

	
	
	/**
	 * Gets the signatures bytes associated with this DigitalSignature.
	 * 
	 * @return The signature bytes associated with this 
	 *         DigitalSignature.
	 */
	public byte[] getSignatureBytes() {
	    log.debug("Exiting getPublicKey(): {}", 
	            Arrays.copyOf(this.signatureBytes, this.signatureBytes.length));
		return Arrays.copyOf(this.signatureBytes, this.signatureBytes.length);
    }

	

	/**
	 * Gets the signer associated with this DigitalSignature.
	 * 
	 * @return the signer associated with this DigitalSignature.
	 */
	public String getSigner() {
	    log.debug("Exiting getSigner(): {}", this.signer);
        return this.signer;
    }

	

	/**
	 *  Assists in implementing Object.toString() methods using reflection.
	 *  This class uses reflection to determine the fields to append. Because 
	 *  these fields are usually private, the class changes the visibility of 
	 *  the fields. This will fail under a security manager,
	 *  unless the appropriate permissions are set up correctly. 
	 */
	@Override
	public String toString() {
	    log.debug("Entering toString()");
        String toString = ReflectionToStringBuilder.toString(this,
                ToStringStyle.SHORT_PREFIX_STYLE);
        log.debug("Exiting toString(): {}", toString);
        return toString;
    }
	
	/**
     * Sets the logger for this class.
     * 
     * @param log The logger for this class.
     */
    @AutowiredLogger
    public void setLog(Logger log) {
        this.log = log;
    }
}
